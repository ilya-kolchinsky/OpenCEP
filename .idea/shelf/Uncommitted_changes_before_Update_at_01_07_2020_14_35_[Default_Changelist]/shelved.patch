Index: evaluation/TreeBasedEvaluationMechanism.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC\r\nfrom datetime import timedelta, datetime\r\nfrom base.Pattern import Pattern\r\nfrom base.PatternStructure import SeqOperator, QItem, NegationOperator\r\nfrom base.Formula import TrueFormula, Formula\r\nfrom evaluation.PartialMatch import PartialMatch\r\nfrom misc.IOUtils import Stream\r\nfrom typing import List, Tuple\r\nfrom base.Event import Event\r\nfrom misc.Utils import merge, merge_according_to, is_sorted, find_partial_match_by_timestamp, get_index, \\\r\n    find_positive_events_before\r\nfrom base.PatternMatch import PatternMatch\r\nfrom evaluation.EvaluationMechanism import EvaluationMechanism\r\nfrom queue import Queue\r\n\r\n\r\n# check_expired_timestamp = set()\r\n\r\nclass Node(ABC):\r\n    \"\"\"\r\n    This class represents a single node of an evaluation tree.\r\n    \"\"\"\r\n\r\n    def __init__(self, sliding_window: timedelta, parent):\r\n        self._parent = parent\r\n        self._sliding_window = sliding_window\r\n        self._partial_matches = []\r\n        self._condition = TrueFormula()\r\n        # matches that were not yet pushed to the parent for further processing\r\n        self._unhandled_partial_matches = Queue()\r\n\r\n    def consume_first_partial_match(self):\r\n        \"\"\"\r\n        Removes and returns a single partial match buffered at this node.\r\n        Used in the root node to collect full pattern matches.\r\n        \"\"\"\r\n        ret = self._partial_matches[0]\r\n        del self._partial_matches[0]\r\n        return ret\r\n\r\n    def has_partial_matches(self):\r\n        \"\"\"\r\n        Returns True if this node contains any partial matches and False otherwise.\r\n        \"\"\"\r\n        return len(self._partial_matches) > 0\r\n\r\n    def get_last_unhandled_partial_match(self):\r\n        \"\"\"\r\n        Returns the last partial match buffered at this node and not yet transferred to its parent.\r\n        \"\"\"\r\n        return self._unhandled_partial_matches.get()\r\n\r\n    def set_parent(self, parent):\r\n        \"\"\"\r\n        Sets the parent of this node.\r\n        \"\"\"\r\n        self._parent = parent\r\n\r\n    def clean_expired_partial_matches(self, last_timestamp: datetime):\r\n        \"\"\"\r\n        Removes partial matches whose earliest timestamp violates the time window constraint.\r\n        \"\"\"\r\n        if self._sliding_window == timedelta.max:\r\n            return\r\n        count = find_partial_match_by_timestamp(self._partial_matches, last_timestamp - self._sliding_window)\r\n        self._partial_matches = self._partial_matches[count:]\r\n\r\n        \"\"\"\r\n        \"waiting for timeout\" contains matches that may be invalidated by a future negative event\r\n        if the timestamp has passed, they can't be invalidated anymore,\r\n        therefore we remove them from waiting for timeout\r\n        and we put them in the field \"matches to handle at eof\" of the root,\r\n        for it to put it in the matches at the end of the program\r\n        \"\"\"\r\n\r\n        if (type(self) == PostProcessingNode or type(self) == FirstChanceNode) \\\r\n                and self.is_last:\r\n            self._waiting_for_time_out = sorted(self._waiting_for_time_out, key=lambda x: x.first_timestamp)\r\n            count = find_partial_match_by_timestamp(self._waiting_for_time_out, last_timestamp - self._sliding_window)\r\n            node = self\r\n            while node._parent is not None:\r\n                node = node._parent\r\n\r\n            node.matches_to_handle_at_EOF.extend(self._waiting_for_time_out[:count]) # pourquoi ne pas les mettre directement dans root.partial_matches ?\r\n            self._waiting_for_time_out = self._waiting_for_time_out[count:]\r\n\r\n        \"\"\"\r\n        the end of the function is here to handle a special case: a pattern that starts by a negative event, and we got\r\n        a negative event that has invalidated the first part of a match but the second part of the match arrives later,\r\n        with a timestamp not \"influenced\" anymore by the negative event\r\n        example: notA, B, C : A has invalidated B, but C arrives later,\r\n        and the time window doesn't contain A and C at the same time. Therefore B, C is a match.\r\n        If a positive event (C) arrives with a timestamp that exceeds the frame of the negative event (A),\r\n        we want to remove the negative event and try to handle previous pm that were blocked by A (in our case: B)\r\n        Algorithm : we get all the FirstChanceNodes with flag is_first in the subtree of the current node\r\n        for each node, we remove the expired negative events, and we send back to the tree\r\n        all the pms contained in the field \"check_expired_timestamp\" that have been blocked\r\n        by a negative event that has expired.\r\n        \"\"\"\r\n\r\n        if self._parent is not None:\r\n            list_of_nodes = self._parent.get_first_FCNodes()\r\n        else:\r\n            list_of_nodes = self.get_first_FCNodes()\r\n\r\n        for node in list_of_nodes:\r\n            # node._right_subtree.clean_expired_partial_matches(last_timestamp)\r\n            if node._right_subtree._sliding_window == timedelta.max:\r\n                return\r\n            count = find_partial_match_by_timestamp(node._right_subtree._partial_matches,\r\n                                                    last_timestamp - node._right_subtree._sliding_window)\r\n            node._right_subtree._partial_matches = node._right_subtree._partial_matches[count:]\r\n\r\n            \"\"\"\r\n            partial_matches = []\r\n            for x, y in node.check_expired_timestamp.items():\r\n                if x <= last_timestamp:\r\n                    partial_matches.append(y)\r\n            \"\"\"\r\n\r\n            partial_matches = [pm for timestamp, pm in node.check_expired_timestamp if timestamp < last_timestamp]\r\n            # for timestamp, pm in node.check_expired_timestamp:\r\n            #     if timestamp < last_timestamp:\r\n            #         partial_matches.append(pm)\r\n\r\n            for pm in partial_matches:\r\n\r\n                \"\"\"\r\n                \"unblocking\" previous pms that were blocked by an expired neg event may lead to accept as a match\r\n                a pam that is in the time window of the negative event.\r\n                In our previous example, if a C1 arrived earlier and was blocked by A (like it should be),\r\n                removing the A now will cause C1 to go up the tree. Therefore we hold a threshold in a node,\r\n                which is the timestamp that a pm has tà exceed to be a match\r\n                (when B, C1 go all the way up, we want to stop them because they are still in the time window of the previous A)\r\n                By default, the threshold is old by the root. If the root is a FirstChance Node with flag is_last on,\r\n                it may cause errors, and therefore we go down the tree from the root until we find a node that meets the criteria\r\n                \"\"\"\r\n\r\n                node_to_hold_threshold = self\r\n                while node_to_hold_threshold._parent is not None:\r\n                    node_to_hold_threshold = node_to_hold_threshold._parent\r\n\r\n                # need to check also that root.left_subtree is not leaf ?\r\n                while type(node_to_hold_threshold) == FirstChanceNode and node_to_hold_threshold.is_last:\r\n                    node_to_hold_threshold = node_to_hold_threshold._left_subtree\r\n\r\n                node_to_hold_threshold.threshold = last_timestamp\r\n\r\n                # we want to remove the pm from the check_expired_timestamp list\r\n                node.check_expired_timestamp = [x for x in node.check_expired_timestamp if x[1] != pm]\r\n\r\n                node._left_subtree._unhandled_partial_matches.put(pm)\r\n                node.handle_new_partial_match(node._left_subtree)\r\n\r\n                # now we turn the threshold off because we finished to handle this case\r\n                node_to_hold_threshold.threshold = 0\r\n\r\n    def add_partial_match(self, pm: PartialMatch):\r\n        \"\"\"\r\n        Registers a new partial match at this node.\r\n        As of now, the insertion is always by the timestamp, and the partial matches are stored in a list sorted by\r\n        timestamp. Therefore, the insertion operation is performed in O(log n).\r\n        \"\"\"\r\n        index = find_partial_match_by_timestamp(self._partial_matches, pm.first_timestamp)\r\n        self._partial_matches.insert(index, pm)\r\n        if self._parent is not None:\r\n            self._unhandled_partial_matches.put(pm)\r\n\r\n    def get_partial_matches(self):\r\n        \"\"\"\r\n        Returns the currently stored partial matches.\r\n        \"\"\"\r\n        return self._partial_matches\r\n\r\n    def get_first_FCNodes(self):\r\n        \"\"\"\r\n        Returns all FirstChance nodes with flag is_first on in the subtree of self - to be implemented by subclasses.\r\n        \"\"\"\r\n        raise NotImplementedError()\r\n\r\n    def get_leaves(self):\r\n        \"\"\"\r\n        Returns all leaves in this tree - to be implemented by subclasses.\r\n        \"\"\"\r\n        raise NotImplementedError()\r\n\r\n    def apply_formula(self, formula: Formula):\r\n        \"\"\"\r\n        Applies a given formula on all nodes in this tree - to be implemented by subclasses.\r\n        \"\"\"\r\n        raise NotImplementedError()\r\n\r\n    def get_event_definitions(self):\r\n        \"\"\"\r\n        Returns the specifications of all events collected by this tree - to be implemented by subclasses.\r\n        \"\"\"\r\n        raise NotImplementedError()\r\n\r\n    def get_deepest_leave(self):\r\n\r\n        raise NotImplementedError()\r\n\r\nclass LeafNode(Node):\r\n    \"\"\"\r\n    A leaf node is responsible for a single event type of the pattern.\r\n    \"\"\"\r\n\r\n    def __init__(self, sliding_window: timedelta, leaf_index: int, leaf_qitem: QItem, parent: Node):\r\n        super().__init__(sliding_window, parent)\r\n        self.__leaf_index = leaf_index\r\n        self.__event_name = leaf_qitem.name\r\n        self.__event_type = leaf_qitem.event_type\r\n\r\n        # We added an index for every QItem according to its place in the pattern in order to facilitate checking\r\n        # if a PartialMatch is in the right order chronologically (for SEQ)\r\n        self.qitem_index = leaf_qitem.get_event_index()\r\n\r\n    def get_leaves(self):\r\n        return [self]\r\n\r\n    def get_first_FCNodes(self):\r\n        return []\r\n\r\n    def get_deepest_leave(self):\r\n        return self\r\n\r\n    def set_qitem_index(self, index: int):\r\n        self.qitem_index = index\r\n\r\n    def apply_formula(self, formula: Formula):\r\n        condition = formula.get_formula_of(self.__event_name)\r\n        if condition is not None:\r\n            self._condition = condition\r\n\r\n    def get_event_definitions(self):\r\n        return [(self.__leaf_index, QItem(self.__event_type, self.__event_name, self.qitem_index))]\r\n\r\n    def get_event_type(self):\r\n        \"\"\"\r\n        Returns the type of events processed by this leaf.\r\n        \"\"\"\r\n        return self.__event_type\r\n\r\n    def handle_event(self, event: Event):\r\n        \"\"\"\r\n        Inserts the given event to this leaf.\r\n        \"\"\"\r\n        self.clean_expired_partial_matches(event.timestamp)\r\n\r\n        # get event's qitem and make a binding to evaluate formula for the new event.\r\n        binding = {self.__event_name: event.payload}\r\n\r\n        if not self._condition.eval(binding):\r\n            return\r\n\r\n        self.add_partial_match(PartialMatch([event]))\r\n        if self._parent is not None:\r\n            self._parent.handle_new_partial_match(self)\r\n\r\n    def get_event_name(self):\r\n        \"\"\"\r\n        Returns the name of the event processed by this leaf.\r\n        \"\"\"\r\n        return self.__event_name\r\n\r\n\r\nclass InternalNode(Node):\r\n    \"\"\"\r\n    An internal node connects two subtrees, i.e., two subpatterns of the evaluated pattern.\r\n    \"\"\"\r\n\r\n    def __init__(self, sliding_window: timedelta, parent: Node = None, event_defs: List[Tuple[int, QItem]] = None,\r\n                 left: Node = None, right: Node = None):\r\n        super().__init__(sliding_window, parent)\r\n        self._event_defs = event_defs\r\n        self._left_subtree = left\r\n        self._right_subtree = right\r\n        \"\"\"\r\n        Special field to be used in only one node (root or first node which is not a FC node) if the pattern contains\r\n        a negative operator, in mode \"first chance negation\".\r\n        In some cases, contains the threshold timestamp that a pm has to exceed in order to be a match - see clean_expired\r\n        Otherwise is 0\r\n        \"\"\"\r\n        self.threshold = 0\r\n\r\n    def get_leaves(self):\r\n        result = []\r\n        if self._left_subtree is not None:\r\n            result += self._left_subtree.get_leaves()\r\n        if self._right_subtree is not None:\r\n            result += self._right_subtree.get_leaves()\r\n        return result\r\n\r\n    def get_first_FCNodes(self):\r\n        result = []\r\n        if type(self._left_subtree) != LeafNode:\r\n            result += self._left_subtree.get_first_FCNodes()\r\n        if type(self._right_subtree) != LeafNode:\r\n            result += self._right_subtree.get_first_FCNodes()\r\n        return result\r\n\r\n    def get_deepest_leave(self):\r\n        if self._left_subtree is not None:\r\n            return self._left_subtree.get_deepest_leave()\r\n\r\n    def apply_formula(self, formula: Formula):\r\n        names = {item[1].name for item in self._event_defs}\r\n        condition = formula.get_formula_of(names)\r\n        self._condition = condition if condition else TrueFormula()\r\n        self._left_subtree.apply_formula(self._condition)\r\n        self._right_subtree.apply_formula(self._condition)\r\n\r\n    def get_event_definitions(self):\r\n        return self._event_defs\r\n\r\n    def _set_event_definitions(self,\r\n                               left_event_defs: List[Tuple[int, QItem]], right_event_defs: List[Tuple[int, QItem]]):\r\n        \"\"\"\r\n        A helper function for collecting the event definitions from subtrees. To be overridden by subclasses.\r\n        \"\"\"\r\n        self._event_defs = left_event_defs + right_event_defs\r\n\r\n    def set_subtrees(self, left: Node, right: Node):\r\n        \"\"\"\r\n        Sets the subtrees of this node.\r\n        \"\"\"\r\n        self._left_subtree = left\r\n        self._right_subtree = right\r\n        self._set_event_definitions(self._left_subtree.get_event_definitions(),\r\n                                    self._right_subtree.get_event_definitions())\r\n\r\n    def handle_new_partial_match(self, partial_match_source: Node):\r\n        \"\"\"\r\n        Internal node's update for a new partial match in one of the subtrees.\r\n        \"\"\"\r\n        if partial_match_source == self._left_subtree:\r\n            other_subtree = self._right_subtree\r\n        elif partial_match_source == self._right_subtree:\r\n            other_subtree = self._left_subtree\r\n        else:\r\n            raise Exception()  # should never happen\r\n\r\n        new_partial_match = partial_match_source.get_last_unhandled_partial_match()\r\n        first_event_defs = partial_match_source.get_event_definitions()\r\n        other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n        partial_matches_to_compare = other_subtree.get_partial_matches()\r\n        second_event_defs = other_subtree.get_event_definitions()\r\n\r\n        self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        # given a partial match from one subtree, for each partial match\r\n        # in the other subtree we check for new partial matches in this node.\r\n        for partialMatch in partial_matches_to_compare:\r\n            self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs)\r\n\r\n    def _try_create_new_match(self,\r\n                              first_partial_match: PartialMatch, second_partial_match: PartialMatch,\r\n                              first_event_defs: List[Tuple[int, QItem]], second_event_defs: List[Tuple[int, QItem]]):\r\n        \"\"\"\r\n        Verifies all the conditions for creating a new partial match and creates it if all constraints are satisfied.\r\n        \"\"\"\r\n        if self._sliding_window != timedelta.max and \\\r\n                abs(first_partial_match.last_timestamp - second_partial_match.first_timestamp) > self._sliding_window:\r\n            return\r\n        events_for_new_match = self._merge_events_for_new_match(first_event_defs, second_event_defs,\r\n                                                                first_partial_match.events, second_partial_match.events)\r\n\r\n        if not self._validate_new_match(events_for_new_match):\r\n            return\r\n\r\n        # If the threshold is not 0, we accept the pm as a match only if its last timestamp exceeds the threshold\r\n        if self.threshold != 0 and first_partial_match.last_timestamp < self.threshold:\r\n            return\r\n\r\n        self.add_partial_match(PartialMatch(events_for_new_match))\r\n        if self._parent is not None:\r\n            self._parent.handle_new_partial_match(self)\r\n\r\n    def _merge_events_for_new_match(self,\r\n                                    first_event_defs: List[Tuple[int, QItem]],\r\n                                    second_event_defs: List[Tuple[int, QItem]],\r\n                                    first_event_list: List[Event],\r\n                                    second_event_list: List[Event]):\r\n        \"\"\"\r\n        Creates a list of events to be included in a new partial match.\r\n        \"\"\"\r\n        if self._event_defs[0][0] == first_event_defs[0][0]:\r\n            return first_event_list + second_event_list\r\n        if self._event_defs[0][0] == second_event_defs[0][0]:\r\n            return second_event_list + first_event_list\r\n        raise Exception()\r\n\r\n    def _validate_new_match(self, events_for_new_match: List[Event]):\r\n        \"\"\"\r\n        Validates the condition stored in this node on the given set of events.\r\n        \"\"\"\r\n        binding = {\r\n            self._event_defs[i][1].name: events_for_new_match[i].payload for i in range(len(self._event_defs))\r\n        }\r\n        return self._condition.eval(binding)\r\n\r\n    \"\"\"\r\n    def sort_event_def_according_to(self, pattern: Pattern):\r\n        if(type(self) != InternalNegationNode):\r\n            return\r\n        pattern_list = pattern.origin_structure.get_args()\r\n        qitem_list = list(list(zip(*self._event_defs))[1])\r\n\r\n        qitem_list_name = [x.name for x in qitem_list]\r\n\r\n        for name in qitem_list_name:\r\n            if name == self._right_subtree.__event_name:\r\n                index_to_delete = qitem_list_name.index(name)\r\n                tuple_to_insert = self._event_defs.pop(index_to_delete)\r\n                break\r\n\r\n        for p in pattern_list:\r\n            if p.name == name:\r\n                new_index = pattern_list.index(p)\r\n\r\n        list_name = [x.name for x in list_for_sorting]\r\n\r\n\r\n        sorted_qitems = sorted(qitem_list, key=lambda x: x.get_event_index())\r\n        \"\"\"\r\n\r\n\r\nclass AndNode(InternalNode):\r\n    \"\"\"\r\n    An internal node representing an \"AND\" operator.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\nclass SeqNode(InternalNode):\r\n    \"\"\"\r\n    An internal node representing a \"SEQ\" (sequence) operator.\r\n    In addition to checking the time window and condition like the basic node does, SeqNode also verifies the order\r\n    of arrival of the events in the partial matches it constructs.\r\n    \"\"\"\r\n\r\n    def _set_event_definitions(self,\r\n                               left_event_defs: List[Tuple[int, QItem]], right_event_defs: List[Tuple[int, QItem]]):\r\n        self._event_defs = merge(left_event_defs, right_event_defs, key=lambda x: x[0])\r\n\r\n    def _merge_events_for_new_match(self,\r\n                                    first_event_defs: List[Tuple[int, QItem]],\r\n                                    second_event_defs: List[Tuple[int, QItem]],\r\n                                    first_event_list: List[Event],\r\n                                    second_event_list: List[Event]):\r\n        return merge_according_to(first_event_defs, second_event_defs,\r\n                                  first_event_list, second_event_list, key=lambda x: x[0])\r\n\r\n    def _validate_new_match(self, events_for_new_match: List[Event]):\r\n        if not is_sorted(events_for_new_match, key=lambda x: x.timestamp):\r\n            return False\r\n        return super()._validate_new_match(events_for_new_match)\r\n\r\n\r\nclass InternalNegationNode(InternalNode):\r\n    \"\"\"\r\n    Virtual class that represents a NOT operator. Has two subclasses, one for each mode\r\n    \"\"\"\r\n    def __init__(self, sliding_window: timedelta, is_first: bool, is_last: bool, parent: Node = None,\r\n                 event_defs: List[Tuple[int, QItem]] = None,\r\n                 left: Node = None, right: Node = None):\r\n        super().__init__(sliding_window, parent, event_defs, left, right)\r\n        # Those are flags in order to differenciate the NegationNode if they are in the middle of a pattern, at the beginning or at the end\r\n        self.is_first = is_first\r\n        self.is_last = is_last\r\n\r\n        \"\"\"\r\n        Contains PMs that match the whole pattern, but may be invalidated by a negative event later \r\n        We wait for them to exceed the time window and therefore can't be invalidated anymore\r\n        \"\"\"\r\n        self._waiting_for_time_out = []\r\n\r\n        \"\"\"\r\n        Contains PMs that match the whole pattern and were in waiting_for_timeout, and now can't be invalidated anymore\r\n        When we finish all the stream of events we handle them and put them in the output\r\n        \"\"\"\r\n        self.matches_to_handle_at_EOF = []\r\n\r\n    def _set_event_definitions(self,\r\n                               left_event_defs: List[Tuple[int, QItem]], right_event_defs: List[Tuple[int, QItem]]):\r\n        self._event_defs = merge(left_event_defs, right_event_defs, key=get_index)  # test eva à verifier\r\n\r\n    def _merge_events_for_new_match(self,\r\n                                    first_event_defs: List[Tuple[int, QItem]],\r\n                                    second_event_defs: List[Tuple[int, QItem]],\r\n                                    first_event_list: List[Event],\r\n                                    second_event_list: List[Event]):\r\n        return merge_according_to(first_event_defs, second_event_defs,\r\n                                  first_event_list, second_event_list, key=lambda x: x[0])\r\n        # ici aussi faire get_index? En fait on dirait qu'on l'utilise pas finalement... A enlever?\r\n\r\n    def get_event_definitions(self):  # to support multiple neg\r\n        return self._left_subtree.get_event_definitions()  # à verifier\r\n\r\n    def _try_create_new_match(self,\r\n                              first_partial_match: PartialMatch, second_partial_match: PartialMatch,\r\n                              first_event_defs: List[Tuple[int, QItem]], second_event_defs: List[Tuple[int, QItem]]):\r\n\r\n        if self._sliding_window != timedelta.max and \\\r\n                abs(first_partial_match.last_timestamp - second_partial_match.first_timestamp) > self._sliding_window:\r\n            return\r\n\r\n        events_for_new_match = merge_according_to(first_event_defs, second_event_defs,\r\n                                                  first_partial_match.events, second_partial_match.events,\r\n                                                  key=get_index)\r\n\r\n        if not is_sorted(events_for_new_match,\r\n                         key=lambda x: x.timestamp):  # 17.06 ça il faut verifier que si on est dans SEQ...\r\n            return False\r\n        return self._validate_new_match(events_for_new_match)\r\n\r\n    def _validate_new_match(self, events_for_new_match: List[Event]):\r\n        \"\"\"\r\n        Validates the condition stored in this node on the given set of events.\r\n        \"\"\"\r\n        binding = {\r\n            self._event_defs[i][1].name: events_for_new_match[i].payload for i in range(len(self._event_defs))\r\n        }\r\n        return self._condition.eval(binding)\r\n\r\n\r\nclass FirstChanceNode(InternalNegationNode):\r\n    \"\"\"\r\n        An internal node representing a Negation operator in case of FirstChance mode\r\n\r\n    \"\"\"\r\n    def __init__(self, sliding_window: timedelta, is_first: bool, is_last: bool, parent: Node = None,\r\n                 event_defs: List[Tuple[int, QItem]] = None,\r\n                 left: Node = None, right: Node = None):\r\n        super().__init__(sliding_window, is_first, is_last, parent, event_defs, left, right)\r\n\r\n        \"\"\"\r\n        contains PMs invalidated by a negative event,\r\n        but may be part of a bigger pm that exceeds the time window of the neg event later\r\n        \"\"\"\r\n\r\n        self.check_expired_timestamp = []\r\n\r\n    def handle_new_partial_match(self, partial_match_source: Node):\r\n\r\n        if partial_match_source == self._left_subtree:\r\n            # If we received events from the left_subtree => positive events\r\n            # we add them to the partial matches of this node and we continue on\r\n            new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # A1 et C1\r\n            other_subtree = self._right_subtree\r\n\r\n            if self.is_last:\r\n                self._waiting_for_time_out.append(new_partial_match)\r\n                return\r\n\r\n            first_event_defs = partial_match_source.get_event_definitions()\r\n            other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n            partial_matches_to_compare = other_subtree.get_partial_matches()  # B\r\n            second_event_defs = other_subtree.get_event_definitions()\r\n            self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n            invalidate = False\r\n            partialMatch = None\r\n            for partialMatch in partial_matches_to_compare:\r\n                # for every negative event, we want to check if he invalidates new_partial_match\r\n                if self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                    invalidate = True\r\n                    break\r\n\r\n            # if the flag is off is empty, there is no negative event that invalidated the current pm and therefore we go up\r\n            if invalidate is False:\r\n                self.add_partial_match(new_partial_match)\r\n                if self._parent is not None:\r\n                    self._parent.handle_new_partial_match(self)\r\n\r\n            if invalidate:\r\n                # if the new partial match is invalidated we want to check later if the negative event has expired\r\n                if partialMatch.first_timestamp != partialMatch.last_timestamp:\r\n                    print(\"partial match is not leaf event\")\r\n                # check_expired_timestamp.add(partialMatch.first_timestamp + self._sliding_window)\r\n                self.check_expired_timestamp.append((partialMatch.last_timestamp + self._sliding_window,\r\n                                                     new_partial_match))\r\n                # self.check_expired_timestamp[partialMatch.last_timestamp + self._sliding_window] = new_partial_match\r\n                # print(\"test:\", partialMatch.last_timestamp + self._sliding_window)\r\n\r\n            # else we do nothing ? or we need to remove the current pm from the list of pms all the way to the bottom ??\r\n            return\r\n\r\n        elif partial_match_source == self._right_subtree:\r\n            # the current pm is a negative event, we check if it invalidates previous pms\r\n            if self.is_first:\r\n                return\r\n            elif self.is_last:\r\n                self.handle_PM_with_negation_at_the_end(partial_match_source)\r\n                return\r\n            else:\r\n                new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # A1 et C1\r\n\r\n                other_subtree = self._left_subtree\r\n\r\n                first_event_defs = partial_match_source.get_event_definitions()\r\n                other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n                partial_matches_to_compare = other_subtree.get_partial_matches()  # B\r\n                second_event_defs = other_subtree.get_event_definitions()\r\n                self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n                partial_match_to_remove = []\r\n                for partialMatch in partial_matches_to_compare:  # for every negative event, we want to check if he invalidates new_partial_match\r\n                    if self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                        partial_match_to_remove.append(partialMatch)\r\n\r\n                # if the negative event invalidated some pms we want to remove all of them in each negative node in the way up\r\n                for partialMatch in partial_match_to_remove:\r\n                    node = self\r\n                    while node is not None and type(node) == FirstChanceNode:\r\n                        node._remove_partial_matches(partialMatch)\r\n                        node = node._parent\r\n\r\n    def _remove_partial_matches(self, matches_to_remove: List[PartialMatch]):\r\n        matches_to_keep = [match for match in self._partial_matches if match not in matches_to_remove]\r\n        # for match in self._partial_matches:\r\n        #     if match not in matches_to_remove:\r\n        #         matches_to_keep.append(match)\r\n\r\n        self._partial_matches = matches_to_keep\r\n        \"\"\"\r\n        i = 0\r\n        m = set(match_to_remove)\r\n        while i < len(self._partial_matches):\r\n            n = set(self._partial_matches[i].events)\r\n            if n.issubset(set(m)):\r\n                self._partial_matches.pop(i)\r\n            i += 1\r\n        self._partial_matches = [x for x in self._partial_matches.event if not set(x).issubset(m)]\r\n        \"\"\"\r\n\r\n    # This is a customized handle_new_partial_match function especially for PartialMatch that can possibly be invalidated by a later negative event\r\n    def handle_PM_with_negation_at_the_end(self, partial_match_source: Node):\r\n\r\n        other_subtree = self.get_first_last_negative_node()\r\n\r\n        new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # C\r\n        first_event_defs = partial_match_source.get_event_definitions()\r\n        other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        partial_matches_to_compare = self.get_waiting_for_time_out()\r\n        second_event_defs = other_subtree.get_event_definitions()\r\n        self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        matches_to_keep = []\r\n        for partialMatch in partial_matches_to_compare:  # pour chaque pm qu'on a \"bloqué\" on verifie si le nouveau event not va invalider\r\n            if not self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                matches_to_keep.append(partialMatch)\r\n\r\n        other_subtree._waiting_for_time_out = matches_to_keep\r\n\r\n    def get_waiting_for_time_out(self):\r\n        if (type(self._left_subtree) == PostProcessingNode or type(self._left_subtree) == FirstChanceNode) \\\r\n                and self._left_subtree.is_last:\r\n            return self._left_subtree.get_waiting_for_time_out()\r\n        else:\r\n            return self._waiting_for_time_out\r\n\r\n    # This function descends in the tree and returns us the first Node that is not a NegationNode at the end of the Pattern\r\n    def get_first_last_negative_node(self):\r\n        if (type(self._left_subtree) == PostProcessingNode or type(self._left_subtree) == FirstChanceNode) \\\r\n                and self._left_subtree.is_last:\r\n            return self._left_subtree.get_first_last_negative_node()\r\n        else:\r\n            return self\r\n\r\n    def get_first_FCNodes(self):\r\n        if self.is_first:\r\n            return [self]\r\n        else:\r\n            return []\r\n\r\n\r\nclass PostProcessingNode(InternalNegationNode):\r\n    \"\"\"\r\n    An internal node connects two subtrees, i.e., two subpatterns of the evaluated pattern.\r\n    \"\"\"\r\n\r\n    def __init__(self, sliding_window: timedelta, is_first: bool, is_last: bool, parent: Node = None,\r\n                 event_defs: List[Tuple[int, QItem]] = None,\r\n                 left: Node = None, right: Node = None):\r\n        super().__init__(sliding_window, is_first, is_last, parent, event_defs, left, right)\r\n\r\n    \"\"\"\r\n        if type(self._left_subtree) != LeafNode:\r\n            return self._left_subtree._validate_new_match(events_for_new_match)\r\n        else:\r\n            return super()._validate_new_match(events_for_new_match)\r\n\r\n    def _remove_partial_match(self, match_to_remove: List[Event]):\r\n        i = 0\r\n        m = set(match_to_remove)\r\n        while i < len(self._left_subtree._partial_matches):\r\n            n = set(self._left_subtree._partial_matches[i].events)\r\n            if n.issubset(set(m)):\r\n                self._left_subtree._partial_matches.pop(i)\r\n            i += 1\r\n        #self._left_subtree._partial_matches = [x for x in self._left_subtree._partial_matches.event if not set(x).issubset(m)]\r\n    \"\"\"\r\n\r\n    def get_waiting_for_time_out(self):\r\n        if type(self._left_subtree) == PostProcessingNode and self._left_subtree.is_last:\r\n            return self._left_subtree.get_waiting_for_time_out()\r\n        else:\r\n            return self._waiting_for_time_out\r\n\r\n    # This function descends in the tree and returns us the first Node that is not a NegationNode at the end of the Pattern\r\n    def get_first_last_negative_node(self):\r\n        if type(self._left_subtree) == PostProcessingNode and self._left_subtree.is_last:\r\n            return self._left_subtree.get_first_last_negative_node()\r\n        else:\r\n            return self\r\n\r\n    # This is a customized handle_new_partial_match function especially for PartialMatch that can possibly be invalidated by a later negative event\r\n    def handle_PM_with_negation_at_the_end(self, partial_match_source: Node):\r\n\r\n        other_subtree = self.get_first_last_negative_node()\r\n\r\n        new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # C\r\n        first_event_defs = partial_match_source.get_event_definitions()\r\n        other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        partial_matches_to_compare = self.get_waiting_for_time_out()\r\n        second_event_defs = other_subtree.get_event_definitions()\r\n        self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        matches_to_keep = []\r\n        for partialMatch in partial_matches_to_compare:  # pour chaque pm qu'on a \"bloqué\" on verifie si le nouveau event not va invalider\r\n            if not self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                matches_to_keep.append(partialMatch)\r\n\r\n        other_subtree._waiting_for_time_out = matches_to_keep\r\n\r\n    def handle_new_partial_match(self, partial_match_source: Node):\r\n\r\n        if partial_match_source == self._left_subtree:\r\n            other_subtree = self._right_subtree\r\n            if self.is_last:\r\n                new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # A1 et C1\r\n                self._waiting_for_time_out.append(new_partial_match)\r\n                return\r\n\r\n        elif partial_match_source == self._right_subtree:\r\n            if self.is_last:\r\n                self.handle_PM_with_negation_at_the_end(partial_match_source)\r\n            return\r\n            # si on vient de rajouter un QItem qui est NOT, on ne veut rien faire avec,\r\n            # on ne veut ni le faire monter en tant que partial match ni comparer avec les autres.\r\n        else:\r\n            raise Exception()  # should never happen\r\n\r\n        new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # A1 et C1\r\n        first_event_defs = partial_match_source.get_event_definitions()\r\n        other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        partial_matches_to_compare = other_subtree.get_partial_matches()  # B\r\n        second_event_defs = other_subtree.get_event_definitions()\r\n        self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        for partialMatch in partial_matches_to_compare:  # for every negative event, we want to check if he invalidates new_partial_match\r\n            if self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                return\r\n\r\n        self.add_partial_match(new_partial_match)\r\n        if self._parent is not None:\r\n            self._parent.handle_new_partial_match(self)\r\n\r\n\r\nclass Tree:\r\n    \"\"\"\r\n    Represents an evaluation tree. Implements the functionality of constructing an actual tree from a \"tree structure\"\r\n    object returned by a tree builder. Other than that, merely acts as a proxy to the tree root node.\r\n    \"\"\"\r\n\r\n    def __init__(self, tree_structure: tuple, pattern: Pattern):\r\n        # Note that right now only \"flat\" sequence patterns and \"flat\" conjunction patterns are supported\r\n\r\n        # We create a tree with only the positive event and the conditions that apply to them\r\n        temp_root = Tree.__construct_tree(pattern.structure.get_top_operator() == SeqOperator,\r\n                                          tree_structure, pattern.structure.args, pattern.window)\r\n        temp_root.apply_formula(pattern.condition)\r\n\r\n        self.__root = temp_root\r\n\r\n        # According to the flag PostProcessing or FirstChanceProcessing, we add the negative events in a different way\r\n        PostProcessing = False\r\n        if PostProcessing:\r\n            self.__root = self.create_PostProcessing_Tree(temp_root, pattern)\r\n        else:\r\n            self.__root = self.create_FirstChanceNegation_Tree(pattern)\r\n\r\n    def create_FirstChanceNegation_Tree(self, pattern: Pattern):\r\n        negative_event_list = pattern.negative_event.get_args()\r\n        origin_event_list = pattern.origin_structure.get_args()\r\n\r\n        # nathan - 28.06\r\n        check_expired_list = []\r\n\r\n        # init node to use it out of the scope of the for\r\n        node = self.__root\r\n        for p in negative_event_list:\r\n            flag = 1\r\n            p_conditions = pattern.condition.get_events_in_a_condition_with(p.get_event_name())\r\n            set_of_depending_events = set()\r\n            if p_conditions is not None:\r\n                p_conditions.get_all_terms(set_of_depending_events)\r\n            if pattern.origin_structure.get_top_operator() == SeqOperator:\r\n                find_positive_events_before(p, set_of_depending_events, pattern.origin_structure.get_args())\r\n            if p.get_event_name() in set_of_depending_events:\r\n                set_of_depending_events.remove(p.get_event_name())\r\n            # list_of_depending_events = list(set(list_of_depending_events))\r\n            node = self.__root.get_deepest_leave()  # A CHANGER\r\n            while flag:\r\n                names = {item[1].name for item in node.get_event_definitions()}\r\n                result = all(elem in names for elem in set_of_depending_events)\r\n                counter = 0\r\n                if result:\r\n                    while type(node._parent) == FirstChanceNode:\r\n                        node = node._parent\r\n                    if p == origin_event_list[counter]:\r\n                        temporal_root = FirstChanceNode(pattern.window, is_first=True, is_last=False)\r\n                        counter += 1\r\n                    elif len(negative_event_list) - negative_event_list.index(p) \\\r\n                            == len(origin_event_list) - origin_event_list.index(p):\r\n                        temporal_root = FirstChanceNode(pattern.window, is_first=False, is_last=True)\r\n                    else:\r\n                        temporal_root = FirstChanceNode(pattern.window, is_first=False, is_last=False)\r\n\r\n                    # temporal_root = InternalNegationNode(pattern.window, is_first=False, is_last=False)\r\n                    temp_neg_event = LeafNode(pattern.window, 1, p, temporal_root)\r\n                    temp_neg_event.apply_formula(pattern.condition)\r\n                    temporal_root.set_subtrees(node, temp_neg_event)\r\n                    temp_neg_event.set_parent(temporal_root)\r\n                    temporal_root.set_parent(node._parent)\r\n                    node.set_parent(temporal_root)\r\n                    if temporal_root._parent != None:\r\n                        temporal_root._parent.set_subtrees(temporal_root, temporal_root._parent._right_subtree)\r\n\r\n                    names = {item[1].name for item in temporal_root._event_defs}\r\n                    condition = pattern.condition.get_formula_of(names)\r\n                    temporal_root._condition = condition if condition else TrueFormula()\r\n\r\n                    flag = 0\r\n                else:\r\n                    node = node._parent\r\n\r\n        while node._parent != None:\r\n            node = node._parent\r\n        self.__root = node\r\n        # self.reorder_event_def(pattern)\r\n\r\n        return self.__root\r\n\r\n    def create_PostProcessing_Tree(self, temp_root: Node, pattern: Pattern):\r\n\r\n        negative_event_list = pattern.negative_event.get_args()\r\n        origin_event_list = pattern.origin_structure.get_args()\r\n        counter = 0\r\n        for p in negative_event_list:\r\n            if p == origin_event_list[counter]:\r\n                temporal_root = PostProcessingNode(pattern.window, is_first=True, is_last=False)\r\n                counter += 1\r\n            elif len(negative_event_list) - negative_event_list.index(p) \\\r\n                    == len(origin_event_list) - origin_event_list.index(p):\r\n                temporal_root = PostProcessingNode(pattern.window, is_first=False, is_last=True)\r\n            else:\r\n                temporal_root = PostProcessingNode(pattern.window, is_first=False, is_last=False)\r\n\r\n            temp_neg_event = LeafNode(pattern.window, 1, p, temporal_root)\r\n            temporal_root.set_subtrees(temp_root, temp_neg_event)\r\n            temp_neg_event.set_parent(temporal_root)\r\n            temp_root.set_parent(temporal_root)\r\n            temp_root = temp_root._parent\r\n            # Peut être à enlever?\r\n            names = {item[1].name for item in temp_root._event_defs}\r\n            condition = pattern.condition.get_formula_of(names)\r\n            temp_root._condition = condition if condition else TrueFormula()\r\n\r\n        self.__root = temp_root\r\n        # self.reorder_event_def(pattern)\r\n        return self.__root\r\n        # self.__root.apply_formula(pattern.condition)\r\n\r\n    def get_root(self):\r\n        return self.__root\r\n\r\n    def reorder_event_def(self, pattern: Pattern):\r\n        current_node = self.__root\r\n        while type(current_node) != LeafNode:\r\n            # if (type(current_node) == InternalNegationNode):\r\n            current_node._event_defs.sort(key=get_index)\r\n            current_node = current_node._left_subtree\r\n\r\n    def handle_EOF(self, matches: Stream):\r\n        for match in self.__root.matches_to_handle_at_EOF:\r\n            matches.add_item(PatternMatch(match.events))\r\n        node = self.__root.get_first_last_negative_node()\r\n        for match in node._waiting_for_time_out:\r\n            matches.add_item(PatternMatch(match.events))\r\n\r\n    def get_leaves(self):\r\n        return self.__root.get_leaves()\r\n\r\n    def get_matches(self):\r\n        while self.__root.has_partial_matches():\r\n            yield self.__root.consume_first_partial_match().events\r\n\r\n    @staticmethod\r\n    def __construct_tree(is_sequence: bool, tree_structure: tuple or int, args: List[QItem],\r\n                         sliding_window: timedelta, parent: Node = None):\r\n        if type(tree_structure) == int:\r\n            return LeafNode(sliding_window, tree_structure, args[tree_structure], parent)\r\n        current = SeqNode(sliding_window, parent) if is_sequence else AndNode(sliding_window, parent)\r\n        left_structure, right_structure = tree_structure\r\n        left = Tree.__construct_tree(is_sequence, left_structure, args, sliding_window, current)\r\n        right = Tree.__construct_tree(is_sequence, right_structure, args, sliding_window, current)\r\n        current.set_subtrees(left, right)\r\n        return current\r\n\r\n\r\nclass TreeBasedEvaluationMechanism(EvaluationMechanism):\r\n    \"\"\"\r\n    An implementation of the tree-based evaluation mechanism.\r\n    \"\"\"\r\n\r\n    def __init__(self, pattern: Pattern, tree_structure: tuple):\r\n        self.__tree = Tree(tree_structure, pattern)\r\n\r\n    def eval(self, events: Stream, matches: Stream):\r\n        event_types_listeners = {}\r\n        # register leaf listeners for event types.\r\n        for leaf in self.__tree.get_leaves():\r\n            event_type = leaf.get_event_type()\r\n            if event_type in event_types_listeners.keys():\r\n                event_types_listeners[event_type].append(leaf)\r\n            else:\r\n                event_types_listeners[event_type] = [leaf]\r\n\r\n        # Send events to listening leaves.\r\n        for event in events:\r\n            if event.event_type in event_types_listeners.keys():\r\n                for leaf in event_types_listeners[event.event_type]:\r\n                    leaf.handle_event(event)\r\n                    for match in self.__tree.get_matches():\r\n                        matches.add_item(PatternMatch(match))\r\n\r\n        # if type(self.__tree.get_root()) == InternalNegationNode and self.__tree.get_root().is_last:\r\n        # if type(self.__tree.get_root()) == PostProcessingNode and self.__tree.get_root().is_last:\r\n        #     self.__tree.handle_EOF(matches)\r\n        # if type(self.__tree.get_root()) == FirstChanceNode and self.__tree.get_root().is_last:\r\n        #     self.__tree.handle_EOF(matches)\r\n\r\n        if (type(self.__tree.get_root()) == PostProcessingNode or type(self.__tree.get_root()) == FirstChanceNode) \\\r\n                and self.__tree.get_root().is_last:\r\n            self.__tree.handle_EOF(matches)\r\n\r\n        matches.close()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- evaluation/TreeBasedEvaluationMechanism.py	(revision ff59e104a69946b0093ea9a37e6d7366d28c4d00)
+++ evaluation/TreeBasedEvaluationMechanism.py	(date 1593602933421)
@@ -14,7 +14,6 @@
 from queue import Queue
 
 
-# check_expired_timestamp = set()
 
 class Node(ABC):
     """
@@ -65,95 +64,39 @@
         count = find_partial_match_by_timestamp(self._partial_matches, last_timestamp - self._sliding_window)
         self._partial_matches = self._partial_matches[count:]
 
-        """
-        "waiting for timeout" contains matches that may be invalidated by a future negative event
-        if the timestamp has passed, they can't be invalidated anymore,
-        therefore we remove them from waiting for timeout
-        and we put them in the field "matches to handle at eof" of the root,
-        for it to put it in the matches at the end of the program
-        """
-
         if (type(self) == PostProcessingNode or type(self) == FirstChanceNode) \
                 and self.is_last:
-            self._waiting_for_time_out = sorted(self._waiting_for_time_out, key=lambda x: x.first_timestamp)
             count = find_partial_match_by_timestamp(self._waiting_for_time_out, last_timestamp - self._sliding_window)
             node = self
             while node._parent is not None:
                 node = node._parent
-
-            node.matches_to_handle_at_EOF.extend(self._waiting_for_time_out[:count]) # pourquoi ne pas les mettre directement dans root.partial_matches ?
+            node.matches_to_handle_at_EOF.extend(self._waiting_for_time_out[:count])
             self._waiting_for_time_out = self._waiting_for_time_out[count:]
 
-        """
-        the end of the function is here to handle a special case: a pattern that starts by a negative event, and we got
-        a negative event that has invalidated the first part of a match but the second part of the match arrives later,
-        with a timestamp not "influenced" anymore by the negative event
-        example: notA, B, C : A has invalidated B, but C arrives later,
-        and the time window doesn't contain A and C at the same time. Therefore B, C is a match.
-        If a positive event (C) arrives with a timestamp that exceeds the frame of the negative event (A),
-        we want to remove the negative event and try to handle previous pm that were blocked by A (in our case: B)
-        Algorithm : we get all the FirstChanceNodes with flag is_first in the subtree of the current node
-        for each node, we remove the expired negative events, and we send back to the tree
-        all the pms contained in the field "check_expired_timestamp" that have been blocked
-        by a negative event that has expired.
-        """
-
         if self._parent is not None:
             list_of_nodes = self._parent.get_first_FCNodes()
         else:
             list_of_nodes = self.get_first_FCNodes()
 
+        root = self
+        while root._parent is not None:
+            root = root._parent
+
+        root.threshold = last_timestamp
+
         for node in list_of_nodes:
-            # node._right_subtree.clean_expired_partial_matches(last_timestamp)
             if node._right_subtree._sliding_window == timedelta.max:
                 return
-            count = find_partial_match_by_timestamp(node._right_subtree._partial_matches,
-                                                    last_timestamp - node._right_subtree._sliding_window)
+            count = find_partial_match_by_timestamp(node._right_subtree._partial_matches, last_timestamp - node._right_subtree._sliding_window)
             node._right_subtree._partial_matches = node._right_subtree._partial_matches[count:]
 
-            """
-            partial_matches = []
-            for x, y in node.check_expired_timestamp.items():
-                if x <= last_timestamp:
-                    partial_matches.append(y)
-            """
-
-            partial_matches = [pm for timestamp, pm in node.check_expired_timestamp if timestamp < last_timestamp]
-            # for timestamp, pm in node.check_expired_timestamp:
-            #     if timestamp < last_timestamp:
-            #         partial_matches.append(pm)
-
+            partial_matches = [v for k, v in node.check_expired_timestamp.items() if k <= last_timestamp]
             for pm in partial_matches:
-
-                """
-                "unblocking" previous pms that were blocked by an expired neg event may lead to accept as a match
-                a pam that is in the time window of the negative event.
-                In our previous example, if a C1 arrived earlier and was blocked by A (like it should be),
-                removing the A now will cause C1 to go up the tree. Therefore we hold a threshold in a node,
-                which is the timestamp that a pm has tà exceed to be a match
-                (when B, C1 go all the way up, we want to stop them because they are still in the time window of the previous A)
-                By default, the threshold is old by the root. If the root is a FirstChance Node with flag is_last on,
-                it may cause errors, and therefore we go down the tree from the root until we find a node that meets the criteria
-                """
-
-                node_to_hold_threshold = self
-                while node_to_hold_threshold._parent is not None:
-                    node_to_hold_threshold = node_to_hold_threshold._parent
-
-                # need to check also that root.left_subtree is not leaf ?
-                while type(node_to_hold_threshold) == FirstChanceNode and node_to_hold_threshold.is_last:
-                    node_to_hold_threshold = node_to_hold_threshold._left_subtree
-
-                node_to_hold_threshold.threshold = last_timestamp
-
-                # we want to remove the pm from the check_expired_timestamp list
-                node.check_expired_timestamp = [x for x in node.check_expired_timestamp if x[1] != pm]
-
+                node.check_expired_timestamp = {key: val for key, val in node.check_expired_timestamp.items() if val !=pm}
                 node._left_subtree._unhandled_partial_matches.put(pm)
                 node.handle_new_partial_match(node._left_subtree)
 
-                # now we turn the threshold off because we finished to handle this case
-                node_to_hold_threshold.threshold = 0
+        root.threshold = 0
 
     def add_partial_match(self, pm: PartialMatch):
         """
@@ -166,6 +109,13 @@
         if self._parent is not None:
             self._unhandled_partial_matches.put(pm)
 
+        # nathan - 28.06
+        """
+        if pm.last_timestamp in check_expired_timestamp:
+            check_expired_timestamp.remove(pm.last_timestamp)
+            self.check_for_expired_negative_events(pm.last_timestamp)
+        """
+
     def get_partial_matches(self):
         """
         Returns the currently stored partial matches.
@@ -173,9 +123,7 @@
         return self._partial_matches
 
     def get_first_FCNodes(self):
-        """
-        Returns all FirstChance nodes with flag is_first on in the subtree of self - to be implemented by subclasses.
-        """
+
         raise NotImplementedError()
 
     def get_leaves(self):
@@ -200,6 +148,24 @@
 
         raise NotImplementedError()
 
+    """
+    def check_for_expired_negative_events(self, last_timestamp : datetime):
+        node = self.get_deepest_leave()
+        # special case if the parent of the deepest leaf is a first chance node
+        if type(node._parent) == FirstChanceNode:
+            for pm in node.get_partial_matches():
+                # call handle_new_pm ?? problem with get_last_unhandled_pm ??
+                pass
+
+        while node._parent is not None:
+            if type(node._parent) == FirstChanceNode:
+                node._parent._right_subtree.clean_expired_partial_matches(last_timestamp)
+                for pm in node.get_partial_matches():
+                    # call handle_new_pm ?? problem with get_last_unhandled_pm ??
+                    # node._parent.handle_new_partial_match(pm)
+                    pass
+    """
+
 class LeafNode(Node):
     """
     A leaf node is responsible for a single event type of the pattern.
@@ -275,12 +241,9 @@
         self._event_defs = event_defs
         self._left_subtree = left
         self._right_subtree = right
-        """
-        Special field to be used in only one node (root or first node which is not a FC node) if the pattern contains
-        a negative operator, in mode "first chance negation".
-        In some cases, contains the threshold timestamp that a pm has to exceed in order to be a match - see clean_expired
-        Otherwise is 0
-        """
+
+        # special field to be used only in the root,
+        # contains the threshold timestamp that a pm have to exceed to be a match
         self.threshold = 0
 
     def get_leaves(self):
@@ -368,8 +331,8 @@
         if not self._validate_new_match(events_for_new_match):
             return
 
-        # If the threshold is not 0, we accept the pm as a match only if its last timestamp exceeds the threshold
-        if self.threshold != 0 and first_partial_match.last_timestamp < self.threshold:
+        # handle for negation nodes
+        if self._parent is None and self.threshold != 0 and first_partial_match.last_timestamp < self.threshold:
             return
 
         self.add_partial_match(PartialMatch(events_for_new_match))
@@ -407,7 +370,7 @@
         qitem_list = list(list(zip(*self._event_defs))[1])
 
         qitem_list_name = [x.name for x in qitem_list]
-
+        
         for name in qitem_list_name:
             if name == self._right_subtree.__event_name:
                 index_to_delete = qitem_list_name.index(name)
@@ -419,7 +382,7 @@
                 new_index = pattern_list.index(p)
 
         list_name = [x.name for x in list_for_sorting]
-
+        
 
         sorted_qitems = sorted(qitem_list, key=lambda x: x.get_event_index())
         """
@@ -458,9 +421,7 @@
 
 
 class InternalNegationNode(InternalNode):
-    """
-    Virtual class that represents a NOT operator. Has two subclasses, one for each mode
-    """
+
     def __init__(self, sliding_window: timedelta, is_first: bool, is_last: bool, parent: Node = None,
                  event_defs: List[Tuple[int, QItem]] = None,
                  left: Node = None, right: Node = None):
@@ -468,17 +429,11 @@
         # Those are flags in order to differenciate the NegationNode if they are in the middle of a pattern, at the beginning or at the end
         self.is_first = is_first
         self.is_last = is_last
-
-        """
-        Contains PMs that match the whole pattern, but may be invalidated by a negative event later 
-        We wait for them to exceed the time window and therefore can't be invalidated anymore
-        """
+        # This is a list of PartialMatches that are waiting to see if a later Negative event will invalidate them
         self._waiting_for_time_out = []
 
-        """
-        Contains PMs that match the whole pattern and were in waiting_for_timeout, and now can't be invalidated anymore
-        When we finish all the stream of events we handle them and put them in the output
-        """
+        # This is a list of PartialMatches that are ready,
+        # and wait for a possible negative event that might invalidate them
         self.matches_to_handle_at_EOF = []
 
     def _set_event_definitions(self,
@@ -491,8 +446,7 @@
                                     first_event_list: List[Event],
                                     second_event_list: List[Event]):
         return merge_according_to(first_event_defs, second_event_defs,
-                                  first_event_list, second_event_list, key=lambda x: x[0])
-        # ici aussi faire get_index? En fait on dirait qu'on l'utilise pas finalement... A enlever?
+                                  first_event_list, second_event_list, key=lambda x: x[0])  # ici aussi faire get_index? En fait on dirait qu'on l'utilise pas finalement... A enlever?
 
     def get_event_definitions(self):  # to support multiple neg
         return self._left_subtree.get_event_definitions()  # à verifier
@@ -525,21 +479,13 @@
 
 
 class FirstChanceNode(InternalNegationNode):
-    """
-        An internal node representing a Negation operator in case of FirstChance mode
 
-    """
     def __init__(self, sliding_window: timedelta, is_first: bool, is_last: bool, parent: Node = None,
                  event_defs: List[Tuple[int, QItem]] = None,
                  left: Node = None, right: Node = None):
         super().__init__(sliding_window, is_first, is_last, parent, event_defs, left, right)
-
-        """
-        contains PMs invalidated by a negative event,
-        but may be part of a bigger pm that exceeds the time window of the neg event later
-        """
-
-        self.check_expired_timestamp = []
+        # check_expired_timestamp = []
+        self.check_expired_timestamp = {}
 
     def handle_new_partial_match(self, partial_match_source: Node):
 
@@ -568,7 +514,7 @@
                     invalidate = True
                     break
 
-            # if the flag is off is empty, there is no negative event that invalidated the current pm and therefore we go up
+            # if the list is empty, there is no negative event that invalidated the current pm and therefore we go up
             if invalidate is False:
                 self.add_partial_match(new_partial_match)
                 if self._parent is not None:
@@ -578,10 +524,8 @@
                 # if the new partial match is invalidated we want to check later if the negative event has expired
                 if partialMatch.first_timestamp != partialMatch.last_timestamp:
                     print("partial match is not leaf event")
-                # check_expired_timestamp.add(partialMatch.first_timestamp + self._sliding_window)
-                self.check_expired_timestamp.append((partialMatch.last_timestamp + self._sliding_window,
-                                                     new_partial_match))
-                # self.check_expired_timestamp[partialMatch.last_timestamp + self._sliding_window] = new_partial_match
+                #check_expired_timestamp.add(partialMatch.first_timestamp + self._sliding_window)
+                self.check_expired_timestamp[partialMatch.last_timestamp + self._sliding_window] = new_partial_match
                 # print("test:", partialMatch.last_timestamp + self._sliding_window)
 
             # else we do nothing ? or we need to remove the current pm from the list of pms all the way to the bottom ??
@@ -677,7 +621,6 @@
         else:
             return []
 
-
 class PostProcessingNode(InternalNegationNode):
     """
     An internal node connects two subtrees, i.e., two subpatterns of the evaluated pattern.
@@ -801,7 +744,7 @@
         origin_event_list = pattern.origin_structure.get_args()
 
         # nathan - 28.06
-        check_expired_list = []
+        check_expired_list =[]
 
         # init node to use it out of the scope of the for
         node = self.__root
@@ -884,9 +827,7 @@
             temp_root._condition = condition if condition else TrueFormula()
 
         self.__root = temp_root
-        # self.reorder_event_def(pattern)
         return self.__root
-        # self.__root.apply_formula(pattern.condition)
 
     def get_root(self):
         return self.__root
@@ -951,14 +892,8 @@
                     for match in self.__tree.get_matches():
                         matches.add_item(PatternMatch(match))
 
-        # if type(self.__tree.get_root()) == InternalNegationNode and self.__tree.get_root().is_last:
-        # if type(self.__tree.get_root()) == PostProcessingNode and self.__tree.get_root().is_last:
-        #     self.__tree.handle_EOF(matches)
-        # if type(self.__tree.get_root()) == FirstChanceNode and self.__tree.get_root().is_last:
-        #     self.__tree.handle_EOF(matches)
-
         if (type(self.__tree.get_root()) == PostProcessingNode or type(self.__tree.get_root()) == FirstChanceNode) \
                 and self.__tree.get_root().is_last:
             self.__tree.handle_EOF(matches)
 
-        matches.close()
\ No newline at end of file
+        matches.close()
Index: test/tests.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nfrom CEP import CEP\r\nfrom evaluation.EvaluationMechanismFactory import EvaluationMechanismTypes, \\\r\n    IterativeImprovementEvaluationMechanismParameters\r\nfrom misc.IOUtils import file_input, file_output, EXPECTEDfile_output\r\nfrom misc.Stocks import MetastockDataFormatter\r\nfrom misc.Utils import generate_matches\r\nfrom evaluation.LeftDeepTreeBuilders import *\r\nfrom evaluation.BushyTreeBuilders import *\r\nfrom datetime import timedelta\r\nfrom base.Formula import GreaterThanFormula, SmallerThanFormula, SmallerThanEqFormula, GreaterThanEqFormula, MulTerm, \\\r\n    EqFormula, IdentifierTerm, AtomicTerm, AndFormula, TrueFormula\r\nfrom base.PatternStructure import AndOperator, SeqOperator, QItem, NegationOperator\r\nfrom base.Pattern import Pattern\r\n\r\nfrom Lib import filecmp\r\n\r\nnasdaqEventStreamShort = file_input(\"test/EventFiles/NASDAQ_SHORT.txt\", MetastockDataFormatter())\r\nnasdaqEventStreamHalfShort = file_input(\"test/EventFiles/NASDAQ_HALF_SHORT.txt\", MetastockDataFormatter())\r\nnasdaqEventStreamMedium = file_input(\"test/EventFiles/NASDAQ_MEDIUM.txt\", MetastockDataFormatter())\r\nnasdaqEventStreamFrequencyTailored = file_input(\"test/EventFiles/NASDAQ_FREQUENCY_TAILORED.txt\",\r\n                                                MetastockDataFormatter())\r\nnasdaqEventStream_AAPL_AMZN_GOOG = file_input(\"test/EventFiles/NASDAQ_AAPL_AMZN_GOOG.txt\", MetastockDataFormatter())\r\nnasdaqEventStream = file_input(\"test/EventFiles/NASDAQ_LONG.txt\", MetastockDataFormatter())\r\n\r\ncustom = file_input(\"test/EventFiles/custom.txt\", MetastockDataFormatter())\r\ncustom2 = file_input(\"test/EventFiles/custom2.txt\", MetastockDataFormatter())\r\nlonger = file_input(\"test/EventFiles/Longer.txt\", MetastockDataFormatter())\r\n\r\njustshort =  file_input(\"test/EventFiles/JustShort.txt\", MetastockDataFormatter())\r\n\r\ndef numOfLinesInPattern(file):\r\n    \"\"\"\r\n    get num of lines in file until first blank line == num of lines in pattern\r\n    :param file: file\r\n    :return: int\r\n    \"\"\"\r\n    counter = 0\r\n    for line in file:\r\n        if line == '\\n':\r\n            break\r\n        counter = counter + 1\r\n    return counter\r\n\r\n\r\ndef compareFiles(path1: str, path2: str):\r\n    \"\"\"\r\n    Compare expected output and actual ouput\r\n    :param path1: path to first file\r\n    :param path2: path to second file\r\n    :return: bool, True if the two files are equivalent\r\n    \"\"\"\r\n    file1 = open(path1)\r\n    file2 = open(path2)\r\n\r\n    counter1 = numOfLinesInPattern(file1)\r\n    counter2 = numOfLinesInPattern(file2)\r\n\r\n    file1.seek(0)\r\n    file2.seek(0)\r\n\r\n    # quick check, if both files don't return the same counter, or if both files are empty\r\n    if counter1 != counter2:\r\n        closeFiles(file1, file2)\r\n        print('dif counters')\r\n        return False\r\n    elif counter1 == counter2 and counter1 == 0:\r\n        closeFiles(file1, file2)\r\n        return True\r\n\r\n    set1 = set()\r\n    set2 = set()\r\n\r\n    fillSet(file1, set1, counter1)\r\n    fillSet(file2, set2, counter2)\r\n    closeFiles(file1, file2)\r\n\r\n    \"\"\"\r\n    with open('set1.txt', 'w') as f:\r\n        print(set1, file=f)\r\n\r\n    with open('set2.txt', 'w') as f:\r\n        print(set2, file=f)\r\n    \"\"\"\r\n    return set1 == set2\r\n\r\n\r\ndef fillSet(file, set: set, counter: int):\r\n    \"\"\"\r\n    fill a set, each element of the set is x consecutive lines of the file, with x = counter\r\n    :param file:\r\n    :param set:\r\n    :param counter:\r\n    :return:\r\n    \"\"\"\r\n    list = []\r\n    tmp = 0\r\n    for line in file:\r\n        if line == '\\n':\r\n            continue\r\n        # solve a problem when no blank lines at end of file\r\n        line = line.strip()\r\n        list.append(line)\r\n        tmp = tmp + 1\r\n        # if we read 'counter' lines, we want to add it to the set, and continue with the next 'counter' lines\r\n        if tmp == counter:\r\n            set.add(tuple(list))\r\n            list = []\r\n            tmp = 0\r\n\r\n\r\ndef closeFiles(file1, file2):\r\n    file1.close()\r\n    file2.close()\r\n\r\n\r\ndef fileCompare(pathA, pathB):\r\n    # return filecmp.cmp(pathA, pathB)\r\n\r\n    file1 = open(pathA)\r\n    file2 = open(pathB)\r\n\r\n    file1List = []  # List of unique patterns\r\n    file2List = []  # List of unique patterns\r\n    lineStack = \"\"\r\n    for line in file1:\r\n        if not line.strip():\r\n            lineStack += line\r\n        elif not (lineStack in file1List):\r\n            file1List.append(lineStack)\r\n            lineStack = \"\"\r\n    lineStack = \"\"\r\n    for line in file2:\r\n        if not line.strip():\r\n            lineStack += line\r\n        elif not (lineStack in file2List):\r\n            file2List.append(lineStack)\r\n            lineStack = \"\"\r\n    if len(file1List) != len(file2List):  # Fast check\r\n        closeFiles(file1, file2)\r\n        return False\r\n    for line in file1List:\r\n        if not (line in file2List):\r\n            closeFiles(file1, file2)\r\n            return False\r\n    for line in file2List:\r\n        if not (line in file1List):\r\n            closeFiles(file1, file2)\r\n            return False\r\n    closeFiles(file1, file2)\r\n    return True\r\n\r\n\r\ndef createTest(testName, patterns, events=None):\r\n    if events == None:\r\n        events = nasdaqEventStream.duplicate()\r\n    else:\r\n        events = events.duplicate()\r\n    pattern = patterns[0]\r\n    matches = generate_matches(pattern, events)\r\n    file_output(matches, '../TestsExpected/%sMatches.txt' % testName)\r\n    print(\"Finished creating test %s\" % testName)\r\n\r\n\r\ndef runTest(testName, patterns, createTestFile=False,\r\n            eval_mechanism_type=EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=None, events=None):\r\n    if createTestFile:\r\n        createTest(testName, patterns, events)\r\n    \"\"\"\r\n    if events is None:\r\n        events = nasdaqEventStream.duplicate()\r\n    else:\r\n        events = events.duplicate()\r\n    \"\"\"\r\n    # nathan\r\n    listShort = [\"OneNotBegin\", \"MultipleNotBegin\"]\r\n    listHalfShort = [\"OneNotEnd\", \"MultipleNotEnd\", \"DUMMYOneNotEnd\"]\r\n    listCustom = [\"MultipleNotBeginAndEnd\", \"DUMMYMultipleNotBeginAndEnd\"]\r\n    listCustom2 = [\"DUMMYsimpleNot\", \"simpleNot\"]\r\n    if testName in listShort:\r\n        events = nasdaqEventStreamShort.duplicate()\r\n    elif testName in listHalfShort:\r\n        events = nasdaqEventStreamHalfShort.duplicate()\r\n    elif testName in listCustom:\r\n        events = custom.duplicate()\r\n    elif testName in listCustom2:\r\n        events = custom2.duplicate()\r\n\r\n    #LongerEventStream = file_input(\"test/EventFiles/Longer.txt\", MetastockDataFormatter())\r\n    #events = longer.duplicate()\r\n    #testName = 'PROBLEM'\r\n\r\n    # events = justshort.duplicate()\r\n\r\n    cep = CEP(patterns, eval_mechanism_type, eval_mechanism_params)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    file_output(matches, '%sMatches.txt' % testName)\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % testName\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % testName\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (testName,\r\n                                                   \"Succeeded\" if compareFiles(actual_matches_path,\r\n                                                                               expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef oneArgumentsearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\")]),\r\n        GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), AtomicTerm(135)),\r\n        timedelta.max\r\n    )\r\n    runTest(\"one\", [pattern], createTestFile)\r\n\r\n\r\ndef simplePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AVID\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"simple\", [pattern], createTestFile)\r\n\r\n\r\ndef googleAscendPatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for a short ascend in the Google peak prices.\r\n    PATTERN SEQ(GoogleStockPriceUpdate a, GoogleStockPriceUpdate b, GoogleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice\r\n    WITHIN 3 minutes\r\n    \"\"\"\r\n    googleAscendPattern = Pattern(\r\n        SeqOperator([QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    runTest('googleAscend', [googleAscendPattern], createTestFile)\r\n\r\n\r\ndef amazonInstablePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for an in-stable day for Amazon.\r\n    PATTERN SEQ(AmazonStockPriceUpdate x1, AmazonStockPriceUpdate x2, AmazonStockPriceUpdate x3)\r\n    WHERE x1.LowestPrice <= 75 AND x2.PeakPrice >= 78 AND x3.LowestPrice <= x1.LowestPrice\r\n    WITHIN 1 day\r\n    \"\"\"\r\n    amazonInstablePattern = Pattern(\r\n        SeqOperator([QItem(\"AMZN\", \"x1\"), QItem(\"AMZN\", \"x2\"), QItem(\"AMZN\", \"x3\")]),\r\n        AndFormula(\r\n            SmallerThanEqFormula(IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]), AtomicTerm(75)),\r\n            AndFormula(\r\n                GreaterThanEqFormula(IdentifierTerm(\"x2\", lambda x: x[\"Peak Price\"]), AtomicTerm(78)),\r\n                SmallerThanEqFormula(IdentifierTerm(\"x3\", lambda x: x[\"Lowest Price\"]),\r\n                                     IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]))\r\n            )\r\n        ),\r\n        timedelta(days=1)\r\n    )\r\n    runTest('amazonInstable', [amazonInstablePattern], createTestFile)\r\n\r\n\r\ndef msftDrivRacePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for a race between driv and microsoft in ten minutes\r\n    PATTERN SEQ(MicrosoftStockPriceUpdate a, DrivStockPriceUpdate b, MicrosoftStockPriceUpdate c, DrivStockPriceUpdate d, MicrosoftStockPriceUpdate e)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice AND c.PeakPrice < d.PeakPrice AND d.PeakPrice < e.PeakPrice\r\n    WITHIN 10 minutes\r\n    \"\"\"\r\n    msftDrivRacePattern = Pattern(\r\n        SeqOperator(\r\n            [QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"MSFT\", \"c\"), QItem(\"DRIV\", \"d\"), QItem(\"MSFT\", \"e\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"e\", lambda x: x[\"Peak Price\"]))\r\n            )\r\n        ),\r\n        timedelta(minutes=10)\r\n    )\r\n    runTest('msftDrivRace', [msftDrivRacePattern], createTestFile)\r\n\r\n\r\ndef googleIncreasePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This Pattern is looking for a 1% increase in the google stock in a half-hour.\r\n    PATTERN SEQ(GoogleStockPriceUpdate a, GoogleStockPriceUpdate b)\r\n    WHERE b.PeakPrice >= 1.01 * a.PeakPrice\r\n    WITHIN 30 minutes\r\n    \"\"\"\r\n    googleIncreasePattern = Pattern(\r\n        SeqOperator([QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\")]),\r\n        GreaterThanEqFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                             MulTerm(AtomicTerm(1.01), IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]))),\r\n        timedelta(minutes=30)\r\n    )\r\n    runTest('googleIncrease', [googleIncreasePattern], createTestFile)\r\n\r\n\r\ndef amazonSpecificPatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for an amazon stock in peak price of 73.\r\n    \"\"\"\r\n    amazonSpecificPattern = Pattern(\r\n        SeqOperator([QItem(\"AMZN\", \"a\")]),\r\n        EqFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), AtomicTerm(73))\r\n    )\r\n    runTest('amazonSpecific', [amazonSpecificPattern], createTestFile)\r\n\r\n\r\ndef googleAmazonLowPatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for low prices of Amazon and Google at the same minute.\r\n    PATTERN AND(AmazonStockPriceUpdate a, GoogleStockPriceUpdate g)\r\n    WHERE a.PeakPrice <= 73 AND g.PeakPrice <= 525\r\n    WITHIN 1 minute\r\n    \"\"\"\r\n    googleAmazonLowPattern = Pattern(\r\n        AndOperator([QItem(\"AMZN\", \"a\"), QItem(\"GOOG\", \"g\")]),\r\n        AndFormula(\r\n            SmallerThanEqFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), AtomicTerm(73)),\r\n            SmallerThanEqFormula(IdentifierTerm(\"g\", lambda x: x[\"Peak Price\"]), AtomicTerm(525))\r\n        ),\r\n        timedelta(minutes=1)\r\n    )\r\n    runTest('googleAmazonLow', [googleAmazonLowPattern], createTestFile)\r\n\r\n\r\ndef nonsensePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for something that does not make sense.\r\n    PATTERN AND(AmazonStockPriceUpdate a, AvidStockPriceUpdate b, AppleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice AND c.PeakPrice < a.PeakPrice\r\n    \"\"\"\r\n    nonsensePattern = Pattern(\r\n        AndOperator([QItem(\"AMZN\", \"a\"), QItem(\"AVID\", \"b\"), QItem(\"AAPL\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]))\r\n            )\r\n        ),\r\n        timedelta(minutes=1)\r\n    )\r\n    runTest('nonsense', [nonsensePattern], createTestFile)\r\n\r\n\r\ndef hierarchyPatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    The following pattern is looking for Amazon < Apple < Google cases in one minute windows.\r\n    PATTERN AND(AmazonStockPriceUpdate a, AppleStockPriceUpdate b, GoogleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice\r\n    WITHIN 1 minute\r\n    \"\"\"\r\n    hierarchyPattern = Pattern(\r\n        AndOperator([QItem(\"AMZN\", \"a\"), QItem(\"AAPL\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=1)\r\n    )\r\n    runTest('hierarchy', [hierarchyPattern], createTestFile)\r\n\r\n\r\ndef multiplePatternSearchTest(createTestFile=False):\r\n    amazonInstablePattern = Pattern(\r\n        SeqOperator([QItem(\"AMZN\", \"x1\"), QItem(\"AMZN\", \"x2\"), QItem(\"AMZN\", \"x3\")]),\r\n        AndFormula(\r\n            SmallerThanEqFormula(IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]), AtomicTerm(75)),\r\n            AndFormula(\r\n                GreaterThanEqFormula(IdentifierTerm(\"x2\", lambda x: x[\"Peak Price\"]), AtomicTerm(78)),\r\n                SmallerThanEqFormula(IdentifierTerm(\"x3\", lambda x: x[\"Lowest Price\"]),\r\n                                     IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]))\r\n            )\r\n        ),\r\n        timedelta(days=1)\r\n    )\r\n    googleAscendPattern = Pattern(\r\n        SeqOperator([QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    runTest('multiplePatterns', [amazonInstablePattern, googleAscendPattern], createTestFile)\r\n\r\n\r\ndef nonFrequencyPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"LOCM\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"nonFrequency\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"LOCM\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 460, \"AMZN\": 442, \"LOCM\": 219})\r\n    runTest(\"frequency\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef arrivalRatesPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"LOCM\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.ARRIVAL_RATES, [0.0159, 0.0153, 0.0076])\r\n    runTest(\"arrivalRates\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef nonFrequencyPatternSearch2Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"LOCM\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AAPL\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"nonFrequency2\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearch2Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"LOCM\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AAPL\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 2, \"AMZN\": 3, \"LOCM\": 1})\r\n    runTest(\"frequency2\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef nonFrequencyPatternSearch3Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AAPL\", \"b\"), QItem(\"AAPL\", \"c\"), QItem(\"LOCM\", \"d\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"nonFrequency3\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearch3Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AAPL\", \"b\"), QItem(\"AAPL\", \"c\"), QItem(\"LOCM\", \"d\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 460, \"LOCM\": 219})\r\n    runTest(\"frequency3\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef nonFrequencyPatternSearch4Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AVID\", \"c\"), QItem(\"LOCM\", \"d\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    runTest(\"nonFrequency4\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearch4Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AVID\", \"c\"), QItem(\"LOCM\", \"d\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AVID\": 1, \"LOCM\": 2, \"AAPL\": 3, \"AMZN\": 4})\r\n    runTest(\"frequency4\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef nonFrequencyPatternSearch5Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator(\r\n            [QItem(\"AAPL\", \"a1\"), QItem(\"LOCM\", \"b1\"), QItem(\"AAPL\", \"a2\"), QItem(\"LOCM\", \"b2\"), QItem(\"AAPL\", \"a3\"),\r\n             QItem(\"LOCM\", \"b3\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    runTest(\"nonFrequency5\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearch5Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator(\r\n            [QItem(\"AAPL\", \"a1\"), QItem(\"LOCM\", \"b1\"), QItem(\"AAPL\", \"a2\"), QItem(\"LOCM\", \"b2\"), QItem(\"AAPL\", \"a3\"),\r\n             QItem(\"LOCM\", \"b3\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"LOCM\": 1, \"AAPL\": 2})  # {\"AAPL\": 460, \"LOCM\": 219}\r\n    runTest(\"frequency5\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef frequencyPatternSearch6Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator(\r\n            [QItem(\"AAPL\", \"a1\"), QItem(\"LOCM\", \"b1\"), QItem(\"AAPL\", \"a2\"), QItem(\"LOCM\", \"b2\"), QItem(\"AAPL\", \"a3\"),\r\n             QItem(\"LOCM\", \"b3\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 1, \"LOCM\": 2})  # {\"AAPL\": 460, \"LOCM\": 219}\r\n    runTest(\"frequency6\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef greedyPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('greedy1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.GREEDY_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef iiRandomPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiRandom1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.SWAP_BASED, IterativeImprovementInitType.RANDOM),\r\n            events=nasdaqEventStream)\r\n\r\n\r\ndef iiRandom2PatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiRandom2', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.CIRCLE_BASED, IterativeImprovementInitType.RANDOM),\r\n            events=nasdaqEventStream)\r\n\r\n\r\ndef iiGreedyPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiGreedy1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.SWAP_BASED, IterativeImprovementInitType.GREEDY),\r\n            events=nasdaqEventStream)\r\n\r\n\r\ndef iiGreedy2PatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiGreedy2', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.CIRCLE_BASED, IterativeImprovementInitType.GREEDY),\r\n            events=nasdaqEventStream)\r\n\r\n\r\ndef dpLdPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('dpLd1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.DYNAMIC_PROGRAMMING_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef dpBPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('dpB1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.DYNAMIC_PROGRAMMING_BUSHY_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef zStreamOrdPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('zstream-ord1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.ORDERED_ZSTREAM_BUSHY_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef zStreamPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('zstream1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.ZSTREAM_BUSHY_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef frequencyTailoredPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"DRIV\", \"a\"), QItem(\"MSFT\", \"b\"), QItem(\"CBRL\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    frequencyDict = {\"MSFT\": 256, \"DRIV\": 257, \"CBRL\": 1}\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, frequencyDict)\r\n    runTest('frequencyTailored1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef nonFrequencyTailoredPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"DRIV\", \"a\"), QItem(\"MSFT\", \"b\"), QItem(\"CBRL\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    runTest('nonFrequencyTailored1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef evaTest():\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), NegationOperator(QItem(\"GOOG\", \"c\"))]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]), AtomicTerm(135))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/Problem.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    print('EVA_SUCCESS')\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    extraShort = 'extraShort'\r\n    file_output(matches, '%sMatches.txt' % extraShort)\r\n\r\n    expected_matches_path = \"test/TestsExpected/extraShortMatches.txt\"\r\n    actual_matches_path = \"test/Matches/extraShortMatches.txt\"\r\n\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (extraShort,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef NegAtTheBeginningThatDoesntInvalidatesMatchesTest():\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"AAPL\", \"a\")), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n            ),\r\n            GreaterThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]),\r\n                               AtomicTerm(35))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/JustShort.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'NegAtTheBeginningThatDoesntInvalidatesMatchesTest'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef googleAscendPatternSearchTestWITHNEG():\r\n    \"\"\"\r\n    This pattern is looking for a short ascend in the Google peak prices.\r\n    PATTERN SEQ(GoogleStockPriceUpdate a, GoogleStockPriceUpdate b, GoogleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice\r\n    WITHIN 3 minutes\r\n    \"\"\"\r\n    googleAscendPattern = Pattern(\r\n        SeqOperator(\r\n            [NegationOperator(QItem(\"GGGGG\", \"l\")), QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n\r\n    extraShortEventStream = file_input(\"test/EventFiles/NASDAQ_LONG.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([googleAscendPattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'googleAscend'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    os.remove(actual_matches_path)\r\n\r\n\r\ndef PROBLEM():\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), NegationOperator(QItem(\"AMZN\", \"b\")), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n            ),\r\n            GreaterThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]),\r\n                               AtomicTerm(35))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/PROBLEM.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'PROBLEM'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    # expected_matches = generate_matches(pattern, extraShortEventStream)\r\n    # EXPECTEDfile_output(expected_matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef MultipleNegTest():\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), NegationOperator(QItem(\"AMZN\", \"b\")), NegationOperator(QItem(\"AN\", \"f\")),\r\n                     NegationOperator(QItem(\"AllN\", \"m\")), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n            ),\r\n            GreaterThanFormula(IdentifierTerm(\"f\", lambda x: x[\"Opening Price\"]),\r\n                               AtomicTerm(35))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/JustShort.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'MultipleNeg'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    # expected_matches = generate_matches(pattern, extraShortEventStream)\r\n    # EXPECTEDfile_output(expected_matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef OtherTest():\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"AAPL\", \"a\")), NegationOperator(QItem(\"AMZN\", \"b\")),\r\n                     QItem(\"GOOG\", \"c\"), QItem(\"G\", \"f\")]),\r\n        # SeqOperator([NegationOperator(QItem(\"AAPL\", \"a\")), QItem(\"AMZN\", \"b\"), NegationOperator(QItem(\"AllN\", \"m\")),\r\n        #             QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"AN\", \"f\")), NegationOperator(QItem(\"MMAN\", \"p\"))]),\r\n        AndFormula(SmallerThanFormula(IdentifierTerm(\"f\", lambda x: x[\"Opening Price\"]),\r\n                                      IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"])),\r\n                   SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                                      AtomicTerm(100))\r\n\r\n                   ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/Longer.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'OtherTest'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    # expected_matches = generate_matches(pattern, extraShortEventStream)\r\n    # EXPECTEDfile_output(expected_matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef OtherTestNat():\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"TYP1\", \"x\"))]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/JustShort.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'OtherTestNat'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    # expected_matches = generate_matches(pattern, extraShortEventStream)\r\n    # EXPECTEDfile_output(expected_matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\n# ON NASDAQ SHORT\r\ndef OneNotAtTheBeginningTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"TYP1\", \"x\")), QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"OneNotBegin\", [pattern], createTestFile)\r\n\r\n\r\n# ON NASDAQ SHORT\r\ndef MultipleNotAtTheBeginningTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"TYP1\", \"x\")), NegationOperator(QItem(\"TYP2\", \"y\")),\r\n                     NegationOperator(QItem(\"TYP3\", \"z\")), QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"MultipleNotBegin\", [pattern], createTestFile)\r\n\r\n\r\n# ON NASDAQ *HALF* SHORT\r\ndef OneNotAtTheEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"TYP1\", \"x\"))]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"OneNotEnd\", [pattern], createTestFile)\r\n\r\n# ON NASDAQ *HALF* SHORT\r\ndef DUMMYOneNotAtTheEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"DUMMYOneNotEnd\", [pattern], createTestFile)\r\n\r\n# ON NASDAQ *HALF* SHORT\r\ndef MultipleNotAtTheEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"TYP1\", \"x\")),\r\n                     NegationOperator(QItem(\"TYP2\", \"y\")), NegationOperator(QItem(\"TYP3\", \"z\"))]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"MultipleNotEnd\", [pattern], createTestFile)\r\n\r\n\r\n# ON CUSTOM\r\ndef MultipleNotBeginAndEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"TYP1\", \"x\")),\r\n                     NegationOperator(QItem(\"TYP4\", \"t\")),\r\n                     QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"),\r\n                     QItem(\"GOOG\", \"c\"),\r\n                     NegationOperator(QItem(\"TYP2\", \"y\")),\r\n                     NegationOperator(QItem(\"TYP3\", \"z\"))]),\r\n        AndFormula(\r\n            AndFormula(\r\n                GreaterThanFormula(IdentifierTerm(\"x\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"y\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n            GreaterThanFormula(IdentifierTerm(\"t\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]))\r\n        ),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"MultipleNotBeginAndEnd\", [pattern], createTestFile)\r\n\r\n\r\n# ON CUSTOM\r\ndef DUMMYMultipleNotBeginAndEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"),\r\n                     QItem(\"GOOG\", \"c\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"DUMMYMultipleNotBeginAndEnd\", [pattern], createTestFile)\r\n\r\n\r\n\r\n# ON custom2\r\ndef simpleNotTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), NegationOperator(QItem(\"AMZN\", \"b\")), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"simpleNot\", [pattern], createTestFile)\r\n\r\n# ON custom2\r\ndef DUMMYsimpleNotTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"GOOG\", \"c\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"DUMMYsimpleNot\", [pattern], createTestFile)\r\n\r\n\r\n# ON NASDAQ *HALF* SHORT\r\ndef OneNotAtTheEndWithStatsTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"TYP1\", \"x\"))]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('OneNotEnd', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.CIRCLE_BASED, IterativeImprovementInitType.GREEDY),\r\n            events=nasdaqEventStreamHalfShort)\r\n\r\n# comment to commit and push\r\n# greedyPatternSearchTest()\r\n# evaTest()\r\n# NegAtTheBeginningThatDoesntInvalidatesMatchesTest()\r\n# googleAscendPatternSearchTestWITHNEG()\r\n# PROBLEM()\r\n# MultipleNegTest()\r\n\r\n\r\n# out = compareFiles('test/Matches/dpB1MatcheMatch.txt', 'test/Matches/dpB1MatchesExpect.txt')\r\n# print(out)\r\n\r\n#OtherTestNat()\r\n\r\n# nathan : a verifier !\r\n# OneNotAtTheEndWithStatsTest()\r\n#\r\n\r\n\r\nsimpleNotTest()\r\n\r\n# ON NASDAQ SHORT\r\nOneNotAtTheBeginningTest()\r\n\r\nMultipleNotAtTheBeginningTest()\r\n\r\n# ON NASDAQ HALF SHORT\r\nOneNotAtTheEndTest()\r\nMultipleNotAtTheEndTest()\r\n\r\n# ON CUSTOM\r\nMultipleNotBeginAndEndTest()\r\n\r\n# DUMMYPatternSearchTest_MultipleNotBeginAndEnd()\r\n\r\n\"\"\"\r\nOtherTest()\r\n\r\noneArgumentsearchTest()\r\nsimplePatternSearchTest()\r\ngoogleAscendPatternSearchTest()\r\namazonInstablePatternSearchTest()\r\nmsftDrivRacePatternSearchTest()\r\ngoogleIncreasePatternSearchTest()\r\namazonSpecificPatternSearchTest()\r\ngoogleAmazonLowPatternSearchTest()\r\nnonsensePatternSearchTest()\r\nhierarchyPatternSearchTest()\r\nnonFrequencyPatternSearchTest()\r\narrivalRatesPatternSearchTest()\r\nfrequencyPatternSearchTest()\r\nnonFrequencyPatternSearch2Test()\r\nfrequencyPatternSearch2Test()\r\nnonFrequencyPatternSearch3Test()\r\nfrequencyPatternSearch3Test()\r\nnonFrequencyPatternSearch4Test()\r\nfrequencyPatternSearch4Test()\r\nnonFrequencyPatternSearch5Test()\r\nfrequencyPatternSearch5Test()\r\nfrequencyPatternSearch6Test()\r\ngreedyPatternSearchTest()\r\niiRandomPatternSearchTest()\r\niiRandom2PatternSearchTest()\r\niiGreedyPatternSearchTest()\r\niiGreedy2PatternSearchTest()\r\n#zStreamOrdPatternSearchTest()\r\n#zStreamPatternSearchTest()\r\ndpBPatternSearchTest()\r\ndpLdPatternSearchTest()\r\nnonFrequencyTailoredPatternSearchTest()\r\nfrequencyTailoredPatternSearchTest()\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/tests.py	(revision ff59e104a69946b0093ea9a37e6d7366d28c4d00)
+++ test/tests.py	(date 1593602764899)
@@ -25,6 +25,7 @@
 
 custom = file_input("test/EventFiles/custom.txt", MetastockDataFormatter())
 custom2 = file_input("test/EventFiles/custom2.txt", MetastockDataFormatter())
+
 longer = file_input("test/EventFiles/Longer.txt", MetastockDataFormatter())
 
 justshort =  file_input("test/EventFiles/JustShort.txt", MetastockDataFormatter())
@@ -175,7 +176,7 @@
     """
     # nathan
     listShort = ["OneNotBegin", "MultipleNotBegin"]
-    listHalfShort = ["OneNotEnd", "MultipleNotEnd", "DUMMYOneNotEnd"]
+    listHalfShort = ["OneNotEnd", "MultipleNotEnd"]
     listCustom = ["MultipleNotBeginAndEnd", "DUMMYMultipleNotBeginAndEnd"]
     listCustom2 = ["DUMMYsimpleNot", "simpleNot"]
     if testName in listShort:
@@ -187,12 +188,10 @@
     elif testName in listCustom2:
         events = custom2.duplicate()
 
-    #LongerEventStream = file_input("test/EventFiles/Longer.txt", MetastockDataFormatter())
-    #events = longer.duplicate()
+    LongerEventStream = file_input("test/EventFiles/Longer.txt", MetastockDataFormatter())
+
+    events = longer.duplicate()
     #testName = 'PROBLEM'
-
-    # events = justshort.duplicate()
-
     cep = CEP(patterns, eval_mechanism_type, eval_mechanism_params)
     running_time = cep.run(events)
     matches = cep.get_pattern_match_stream()
@@ -1074,7 +1073,7 @@
                                IdentifierTerm("c", lambda x: x["Opening Price"]))),
         timedelta(minutes=5)
     )
-    runTest("OneNotBegin", [pattern], createTestFile)
+    runTest("OneNotBeginfirstchance", [pattern], createTestFile)
 
 
 # ON NASDAQ SHORT
@@ -1117,24 +1116,6 @@
     )
     runTest("OneNotEnd", [pattern], createTestFile)
 
-# ON NASDAQ *HALF* SHORT
-def DUMMYOneNotAtTheEndTest(createTestFile=False):
-    """
-    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)
-    WHERE   a.OpeningPrice > b.OpeningPrice
-        AND b.OpeningPrice > c.OpeningPrice
-    WITHIN 5 minutes
-    """
-    pattern = Pattern(
-        SeqOperator([QItem("AAPL", "a"), QItem("AMZN", "b"), QItem("GOOG", "c")]),
-        AndFormula(
-            GreaterThanFormula(IdentifierTerm("a", lambda x: x["Opening Price"]),
-                               IdentifierTerm("b", lambda x: x["Opening Price"])),
-            SmallerThanFormula(IdentifierTerm("b", lambda x: x["Opening Price"]),
-                               IdentifierTerm("c", lambda x: x["Opening Price"]))),
-        timedelta(minutes=5)
-    )
-    runTest("DUMMYOneNotEnd", [pattern], createTestFile)
 
 # ON NASDAQ *HALF* SHORT
 def MultipleNotAtTheEndTest(createTestFile=False):
@@ -1284,13 +1265,11 @@
 # nathan : a verifier !
 # OneNotAtTheEndWithStatsTest()
 #
-
-
-simpleNotTest()
+#simpleNotTest()
 
 # ON NASDAQ SHORT
 OneNotAtTheBeginningTest()
-
+"""
 MultipleNotAtTheBeginningTest()
 
 # ON NASDAQ HALF SHORT
@@ -1301,7 +1280,7 @@
 MultipleNotBeginAndEndTest()
 
 # DUMMYPatternSearchTest_MultipleNotBeginAndEnd()
-
+"""
 """
 OtherTest()
 
