Index: base/PatternStructure.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nThese classes are used to represent a \"parameter\" to the PATTERN clause.\r\nThese classes represent a SEQ/AND/OR/KL operator and the atomic argument QItem.\r\nThe classes support nesting. Every operator class has its list of arguments.\r\nThe QItem class has an event type and its name. The name is referred to in\r\na pattern matching condition, represented as formula.\r\n\"\"\"\r\n\r\nfrom abc import ABC\r\nfrom typing import List\r\n\r\n\r\nclass PatternStructure(ABC):\r\n    def get_top_operator(self):\r\n        return type(self)\r\n\r\n    def get_args(self):\r\n        raise NotImplementedError()\r\n\r\n    def duplicate(self):\r\n        raise NotImplementedError()\r\n\r\n    def copy(self):\r\n        raise NotImplementedError()\r\n\r\n    def create_top_operator(self):\r\n        if self.get_top_operator() == SeqOperator:\r\n            return SeqOperator([])\r\n        elif self.get_top_operator() == AndOperator:\r\n            return AndOperator([])\r\n        elif self.get_top_operator() == OrOperator:\r\n            return OrOperator([])\r\n\r\nclass QItem(PatternStructure):\r\n\r\n    def __init__(self, event_type: str, name: str, index: int = None):\r\n        self.event_type = event_type\r\n        self.name = name\r\n        self.index = index\r\n\r\n    def set_qitem_index(self, index: int):\r\n        self.index = index\r\n\r\n    def get_event_name(self):\r\n        return self.name\r\n\r\n    def get_event_index(self):\r\n        return self.index\r\n\r\nclass AndOperator(PatternStructure):\r\n    def __init__(self, args: List[PatternStructure]):\r\n        self.args = args\r\n\r\n    def duplicate(self):\r\n        ret = AndOperator(list(self.args))\r\n        #ret.args = list(self.args)\r\n        return ret\r\n\r\n    def get_args(self):#EVA_17.05\r\n        return self.args\r\n\r\n    def remove_arg(self, pattern: PatternStructure):\r\n        self.args.remove(pattern)\r\n\r\n    def add_arg(self, pattern: PatternStructure):\r\n        self.args.append(pattern)\r\n\r\nclass OrOperator(PatternStructure):\r\n    def __init__(self, args: List[PatternStructure]):\r\n        self.args = args\r\n\r\n    def get_args(self):#EVA_17.05\r\n        return self.args\r\n\r\n    def remove_arg(self, pattern: PatternStructure):\r\n        self.args.remove(pattern)\r\n\r\n    def add_arg(self, pattern: PatternStructure):\r\n        self.args.append(pattern)\r\n\r\n    def duplicate(self):\r\n        ret = OrOperator(list(self.args))\r\n        return ret\r\n\r\nclass SeqOperator(PatternStructure):\r\n    def __init__(self, args: List[PatternStructure]):\r\n        self.args = args\r\n\r\n        \"\"\"\r\n        for pattern in args:\r\n            print(pattern)\r\n            if isinstance(pattern, NegationOperator):\r\n                args.remove(pattern)\r\n        pos_args = [arg for arg in args if not isinstance(arg, NegationOperator)]\r\n        neg_args = [arg for arg in args if isinstance(arg, NegationOperator)]\r\n\r\n        neg_args = []\r\n        for arg in args:\r\n            if isinstance(arg, NegationOperator):\r\n                neg_args.append(arg)\r\n                args.remove(arg)\r\n            try:\r\n                neg_args.append(arg.neg_args)\r\n            except AttributeError:\r\n                pass\r\n        \"\"\"\r\n\r\n    def get_args(self):#EVA_17.05\r\n        return self.args\r\n\r\n    def remove_arg(self, pattern: PatternStructure):\r\n        self.args.remove(pattern)\r\n\r\n    def add_arg(self, pattern: PatternStructure):\r\n        self.args.append(pattern)\r\n\r\n    def duplicate(self):\r\n        ret = SeqOperator(list(self.args))\r\n        return ret\r\n\r\nclass KleeneClosureOperator(PatternStructure):\r\n    def __init__(self, arg: PatternStructure):\r\n        self.arg = arg\r\n\r\n\r\nclass NegationOperator(PatternStructure):\r\n    def __init__(self, arg: PatternStructure):\r\n        self.arg = arg\r\n        self.name = self.get_event_name()\r\n        self.event_type = self.get_event_type()\r\n\r\n    def get_args(self):#EVA_26.05\r\n        return self.arg\r\n\r\n    def get_event_name(self):\r\n        if type(self.arg) == QItem:\r\n            return self.get_args().name\r\n        #pour supporter les nested negation operator rajouter else return une liste de tous les names\r\n\r\n    def get_event_type(self):\r\n        if type(self.arg) == QItem:\r\n            return self.get_args().event_type\r\n\r\n    def get_event_index(self):\r\n        if type(self.arg) == QItem:\r\n            return self.get_args().get_event_index()\r\n\r\n    def set_qitem_index(self, index: int):\r\n        if type(self.arg) == QItem:\r\n            return self.arg.set_qitem_index(index)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- base/PatternStructure.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ base/PatternStructure.py	(date 1593954418288)
@@ -20,9 +20,6 @@
     def duplicate(self):
         raise NotImplementedError()
 
-    def copy(self):
-        raise NotImplementedError()
-
     def create_top_operator(self):
         if self.get_top_operator() == SeqOperator:
             return SeqOperator([])
@@ -53,15 +50,11 @@
 
     def duplicate(self):
         ret = AndOperator(list(self.args))
-        #ret.args = list(self.args)
         return ret
 
-    def get_args(self):#EVA_17.05
+    def get_args(self):
         return self.args
 
-    def remove_arg(self, pattern: PatternStructure):
-        self.args.remove(pattern)
-
     def add_arg(self, pattern: PatternStructure):
         self.args.append(pattern)
 
@@ -69,12 +62,9 @@
     def __init__(self, args: List[PatternStructure]):
         self.args = args
 
-    def get_args(self):#EVA_17.05
+    def get_args(self):
         return self.args
 
-    def remove_arg(self, pattern: PatternStructure):
-        self.args.remove(pattern)
-
     def add_arg(self, pattern: PatternStructure):
         self.args.append(pattern)
 
@@ -86,31 +76,9 @@
     def __init__(self, args: List[PatternStructure]):
         self.args = args
 
-        """
-        for pattern in args:
-            print(pattern)
-            if isinstance(pattern, NegationOperator):
-                args.remove(pattern)
-        pos_args = [arg for arg in args if not isinstance(arg, NegationOperator)]
-        neg_args = [arg for arg in args if isinstance(arg, NegationOperator)]
-
-        neg_args = []
-        for arg in args:
-            if isinstance(arg, NegationOperator):
-                neg_args.append(arg)
-                args.remove(arg)
-            try:
-                neg_args.append(arg.neg_args)
-            except AttributeError:
-                pass
-        """
-
-    def get_args(self):#EVA_17.05
+    def get_args(self):
         return self.args
 
-    def remove_arg(self, pattern: PatternStructure):
-        self.args.remove(pattern)
-
     def add_arg(self, pattern: PatternStructure):
         self.args.append(pattern)
 
@@ -122,29 +90,36 @@
     def __init__(self, arg: PatternStructure):
         self.arg = arg
 
-
 class NegationOperator(PatternStructure):
     def __init__(self, arg: PatternStructure):
         self.arg = arg
+
+        #To support composite patterns, change this to a list of all events_name and their type
         self.name = self.get_event_name()
         self.event_type = self.get_event_type()
 
-    def get_args(self):#EVA_26.05
+    def get_args(self):
         return self.arg
 
     def get_event_name(self):
         if type(self.arg) == QItem:
             return self.get_args().name
-        #pour supporter les nested negation operator rajouter else return une liste de tous les names
+        #To support composite patterns
+        elif type(self.arg) == SeqOperator:
+            return self.get_args().name
 
     def get_event_type(self):
         if type(self.arg) == QItem:
             return self.get_args().event_type
+        # To support composite patterns
+        elif type(self.arg) == SeqOperator:
+            return self.get_args().event_type
 
     def get_event_index(self):
         if type(self.arg) == QItem:
             return self.get_args().get_event_index()
 
+
     def set_qitem_index(self, index: int):
         if type(self.arg) == QItem:
             return self.arg.set_qitem_index(index)
Index: base/Pattern.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from base.Formula import Formula\r\nfrom base.PatternStructure import PatternStructure\r\nfrom datetime import timedelta\r\nfrom misc.StatisticsTypes import StatisticsTypes\r\n\r\nfrom base.Formula import GreaterThanFormula, SmallerThanFormula, SmallerThanEqFormula, GreaterThanEqFormula, MulTerm, EqFormula, IdentifierTerm, AtomicTerm, AndFormula, TrueFormula\r\nfrom base.PatternStructure import AndOperator, SeqOperator, QItem, NegationOperator, OrOperator\r\n\r\nclass Pattern:\r\n    \"\"\"\r\n    A pattern has several fields:\r\n    - a structure represented by a tree of operators over the primitive events (e.g., SEQ(A,B*, AND(C, NOT(D), E)));\r\n    - a condition to be satisfied by the primitive events (might consist of multiple nested conditions);\r\n    - a time window for the pattern matches to occur within.\r\n    A pattern can also carry statistics with it, in order to enable advanced\r\n    tree construction mechanisms - this is hopefully a temporary hack.\r\n    \"\"\"\r\n    def __init__(self, pattern_structure: PatternStructure, pattern_matching_condition: Formula = None,\r\n                 time_window: timedelta = timedelta.max):\r\n        #nathan\r\n        #self.structure = pattern_structure\r\n\r\n        #self.condition = pattern_matching_condition\r\n        self.window = time_window\r\n        self.statistics_type = StatisticsTypes.NO_STATISTICS\r\n        self.statistics = None\r\n\r\n        \"\"\"\r\n        nathan:\r\n        origin structure is the pattern structure that we get in params - containing all the fields\r\n        structure is the origin structure without the negative events\r\n        negative event contains only the negative events of the pattern\r\n        \"\"\"\r\n        self.origin_structure = pattern_structure\r\n        self.structure = pattern_structure.create_top_operator()\r\n        self.negative_event = pattern_structure.create_top_operator()\r\n\r\n        #list = self.origin_structure.get_args()\r\n        self.split_structures()\r\n\r\n        #self.negative_condition_list = list()\r\n        self.condition = pattern_matching_condition\r\n        #self.split_formula()\r\n\r\n    def set_statistics(self, statistics_type: StatisticsTypes, statistics: object):\r\n        self.statistics_type = statistics_type\r\n        self.statistics = statistics\r\n\r\n    def split_structures(self):\r\n        #counter = 0\r\n        for i in range(len(self.origin_structure.get_args())):\r\n            p = self.origin_structure.get_args()[i]\r\n            p.set_qitem_index(i)\r\n            if type(p) == NegationOperator:\r\n                self.negative_event.add_arg(p)\r\n            else:\r\n                self.structure.add_arg(p)\r\n\"\"\"\r\n    def split_formula(self):\r\n        for i in self.negative_event.get_args():\r\n            self.negative_condition_list.append(self.condition.get_formula_of(i.get_event_name()))\r\n\"\"\"
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- base/Pattern.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ base/Pattern.py	(date 1593953903738)
@@ -17,46 +17,34 @@
     """
     def __init__(self, pattern_structure: PatternStructure, pattern_matching_condition: Formula = None,
                  time_window: timedelta = timedelta.max):
-        #nathan
-        #self.structure = pattern_structure
 
-        #self.condition = pattern_matching_condition
         self.window = time_window
         self.statistics_type = StatisticsTypes.NO_STATISTICS
         self.statistics = None
+        self.condition = pattern_matching_condition
 
         """
-        nathan:
-        origin structure is the pattern structure that we get in params - containing all the fields
-        structure is the origin structure without the negative events
-        negative event contains only the negative events of the pattern
+        origin_structure is the pattern structure that we get in params - containing all the fields.
+        structure is the origin structure without the negative events.
+        negative_event contains only the negative events of the pattern.
         """
         self.origin_structure = pattern_structure
         self.structure = pattern_structure.create_top_operator()
         self.negative_event = pattern_structure.create_top_operator()
 
-        #list = self.origin_structure.get_args()
         self.split_structures()
 
-        #self.negative_condition_list = list()
-        self.condition = pattern_matching_condition
-        #self.split_formula()
 
     def set_statistics(self, statistics_type: StatisticsTypes, statistics: object):
         self.statistics_type = statistics_type
         self.statistics = statistics
 
     def split_structures(self):
-        #counter = 0
-        for i in range(len(self.origin_structure.get_args())):
-            p = self.origin_structure.get_args()[i]
+        origin_structure_args = self.origin_structure.get_args()
+        for i in range(len(origin_structure_args)):
+            p = origin_structure_args[i]
             p.set_qitem_index(i)
             if type(p) == NegationOperator:
                 self.negative_event.add_arg(p)
             else:
                 self.structure.add_arg(p)
-"""
-    def split_formula(self):
-        for i in self.negative_event.get_args():
-            self.negative_condition_list.append(self.condition.get_formula_of(i.get_event_name()))
-"""
\ No newline at end of file
Index: misc/Utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nThis file contains various useful functions utilized by different project modules.\r\n\"\"\"\r\n\r\nfrom datetime import datetime\r\nfrom typing import List, Tuple\r\n\r\nfrom base.Pattern import Pattern\r\nfrom base.PatternStructure import QItem\r\nfrom itertools import combinations\r\nfrom base.PatternStructure import SeqOperator, NegationOperator\r\nfrom base.PatternMatch import PatternMatch\r\nfrom copy import deepcopy\r\n\r\nfrom evaluation.PartialMatch import PartialMatch\r\nfrom misc.IOUtils import Stream\r\n\r\n\r\ndef find_partial_match_by_timestamp(partial_matches: List[PartialMatch], timestamp: datetime):\r\n    \"\"\"\r\n    Returns the partial match from the given list such that its timestamp is the closest to the given timestamp.\r\n    The list is assumed to be sorted according to the earliest event timestamp.\r\n    \"\"\"\r\n    # should count how many PMs are before last date.\r\n    length = len(partial_matches)\r\n    if length == 0 or partial_matches[0].first_timestamp >= timestamp:\r\n        return 0\r\n    if length == 1:  # here we already know that first item's date < lastDate\r\n        return 1\r\n    if partial_matches[-1].first_timestamp < timestamp:\r\n        return length\r\n\r\n    start = 0\r\n    end = length - 1\r\n    while start <= end:\r\n        mid = (start + end) // 2\r\n        mid_date = partial_matches[mid].first_timestamp\r\n        if partial_matches[mid - 1].first_timestamp < timestamp <= mid_date:\r\n            return mid\r\n        elif timestamp > mid_date:\r\n            start = mid + 1\r\n        else:\r\n            end = mid - 1\r\n\r\n    # shouldn't get here, because we know not all partial matches are up to date (nor expired),\r\n    # which means an index should be found.\r\n    raise Exception()\r\n\r\n\r\ndef is_float(x: str):\r\n    try:\r\n        _ = float(x)\r\n    except ValueError:\r\n        return False\r\n    else:\r\n        return True\r\n\r\n\r\ndef is_int(x: str):\r\n    try:\r\n        a = float(x)\r\n        b = int(a)\r\n    except ValueError:\r\n        return False\r\n    else:\r\n        return a == b\r\n\r\n\r\ndef str_to_number(x: str):\r\n    if is_int(x):\r\n        return int(x)\r\n    elif is_float(x):\r\n        return float(x)\r\n    else:\r\n        return x\r\n\r\n\r\ndef get_order_by_occurrences(qitems: List[QItem], occurrences: dict):\r\n    \"\"\"\r\n    Sorts the given list according to the occurrences dictionary.\r\n    \"\"\"\r\n    temp_list = [(i, occurrences[qitems[i].event_type]) for i in range(len(qitems))]\r\n    temp_list = sorted(temp_list, key=lambda x: x[1])\r\n    return [i[0] for i in temp_list]\r\n\r\n\r\ndef get_all_disjoint_sets(s: frozenset):\r\n    \"\"\"\r\n    A generator for all disjoint splits of a set.\r\n    \"\"\"\r\n    if len(s) == 2:\r\n        yield (frozenset({t}) for t in s)\r\n        return\r\n\r\n    first = next(iter(s))\r\n    for i in range(len(s) - 1):\r\n        for c in combinations(s.difference({first}), i):\r\n            set1 = frozenset(c).union({first})\r\n            set2 = s.difference(set1)\r\n            yield set1, set2\r\n\r\n\r\ndef merge(arr1: list, arr2: list, key=lambda x: x):\r\n    \"\"\"\r\n    Merges two lists. The comparison is performed according to the given key function.\r\n    \"\"\"\r\n    new_len = len(arr1) + len(arr2)\r\n    ret = []\r\n    i = i1 = i2 = 0\r\n    while i < new_len and i1 < len(arr1) and i2 < len(arr2):\r\n        if key(arr1[i1]) < key(arr2[i2]):\r\n            ret.append(arr1[i1])\r\n            i1 += 1\r\n        else:\r\n            ret.append(arr2[i2])\r\n            i2 += 1\r\n        i += 1\r\n\r\n    while i1 < len(arr1):\r\n        ret.append(arr1[i1])\r\n        i1 += 1\r\n\r\n    while i2 < len(arr2):\r\n        ret.append(arr2[i2])\r\n        i2 += 1\r\n\r\n    return ret\r\n\r\n\r\ndef merge_according_to(arr1: list, arr2: list, actual1: list, actual2: list, key: callable = lambda x: x):\r\n    \"\"\"\r\n    Merge arrays actual1, actual2 according to the way a merge would be done on arr1 and arr2.\r\n    Used in a partial match merge function - the reorders are given, and the partial matches is merged\r\n    according to the reorders.\r\n    \"\"\"\r\n    if len(arr1) != len(actual1) or len(arr2) != len(actual2):\r\n        raise Exception()\r\n\r\n    new_len = len(arr1) + len(arr2)\r\n    ret = []\r\n    i = i1 = i2 = 0\r\n    while i < new_len and i1 < len(arr1) and i2 < len(arr2):\r\n        if key(arr1[i1]) < key(arr2[i2]):\r\n            ret.append(actual1[i1])\r\n            i1 += 1\r\n        else:\r\n            ret.append(actual2[i2])\r\n            i2 += 1\r\n        i += 1\r\n\r\n    while i1 < len(arr1):\r\n        ret.append(actual1[i1])\r\n        i1 += 1\r\n\r\n    while i2 < len(arr2):\r\n        ret.append(actual2[i2])\r\n        i2 += 1\r\n\r\n    return ret\r\n\r\n#def sort_according_to(arr1: list, arr2: list, actual1: list, actual2: list, key: callable = lambda x: x):\r\n\r\n\r\ndef is_sorted(arr: list, key: callable = lambda x: x):\r\n    \"\"\"\r\n    Returns True if the given list is sorted with respect to the given comparator function and False otherwise.\r\n    \"\"\"\r\n    if len(arr) == 0:\r\n        return True\r\n\r\n    for i in range(len(arr) - 1):\r\n        if key(arr[i]) > key(arr[i + 1]):\r\n            return False\r\n\r\n    return True\r\n\r\ndef generate_matches_with_negation(pattern, stream):\r\n    matches = generate_matches(pattern, stream)\r\n    \r\n\r\ndef generate_matches(pattern: Pattern, stream: Stream):\r\n    \"\"\"\r\n    A recursive, very inefficient pattern match finder.\r\n    It is used as our test creator.\r\n    \"\"\"\r\n    args = pattern.structure.args\r\n    types = {qitem.event_type for qitem in args}\r\n    is_seq = (pattern.structure.get_top_operator() == SeqOperator)\r\n    events = {}\r\n    matches = []\r\n    for event in stream:\r\n        if event.event_type in types:\r\n            if event.event_type in events.keys():\r\n                events[event.event_type].append(event)\r\n            else:\r\n                events[event.event_type] = [event]\r\n    generate_matches_recursive(pattern, events, is_seq, [], datetime.max, datetime.min, matches, {})\r\n    return matches\r\n\r\n\r\ndef generate_matches_recursive(pattern: Pattern, events: dict, is_seq: bool, match: list, min_event_timestamp: datetime,\r\n                               max_event_timestamp: datetime,\r\n                               matches: list, binding: dict, loop: int = 0):\r\n    pattern_length = len(pattern.structure.args)\r\n    if loop == pattern_length:\r\n        if pattern.condition.eval(binding):\r\n            if not does_match_exist(matches, match):\r\n                matches.append(PatternMatch(deepcopy(match)))\r\n    else:\r\n        qitem = pattern.structure.args[loop]\r\n        for event in events[qitem.event_type]:\r\n            min_date = min(min_event_timestamp, event.timestamp)\r\n            max_date = max(max_event_timestamp, event.timestamp)\r\n            binding[qitem.name] = event.payload\r\n            if max_date - min_date <= pattern.window:\r\n                if not is_seq or len(match) == 0 or match[-1].timestamp <= event.timestamp:\r\n                    match.append(event)\r\n                    generate_matches_recursive(pattern, events, is_seq, match, min_date, max_date, matches, binding,\r\n                                               loop + 1)\r\n                    del match[-1]\r\n        del binding[qitem.name]\r\n\r\n\r\ndef does_match_exist(matches: list, match: list):\r\n    \"\"\"\r\n    Returns True if the given match exists in the list of matches and False otherwise.\r\n    \"\"\"\r\n    for match2 in matches:\r\n        if len(match) == len(match2.events):\r\n            is_equal = True\r\n            for i in range(len(match)):\r\n                if match[i] != match2.events[i]:\r\n                    is_equal = False\r\n                    break\r\n            if is_equal:\r\n                return True\r\n    return False\r\n\r\n#EVA 12/06\r\n\r\ndef get_index(first_event_def):\r\n    return first_event_def[1].index\r\n\r\ndef find_positive_events_before(p: NegationOperator, set: set, origin: list):\r\n    for e in origin:\r\n        if e == p:\r\n            break\r\n        if type(e) != NegationOperator:\r\n            set.add(e.get_event_name())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- misc/Utils.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ misc/Utils.py	(date 1593954632258)
@@ -236,7 +236,6 @@
                 return True
     return False
 
-#EVA 12/06
 
 def get_index(first_event_def):
     return first_event_def[1].index
Index: misc/IOUtils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from base.DataFormatter import DataFormatter\r\nfrom base.Event import Event\r\nfrom queue import Queue\r\n\r\n\r\nclass Stream:\r\n    \"\"\"\r\n    Represents a generic stream of objects.\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.__stream = Queue()\r\n\r\n    def __next__(self):\r\n        next_item = self.__stream.get(block=True)  # Blocking get\r\n        if next_item is None:\r\n            raise StopIteration()\r\n        return next_item\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def add_item(self, item: object):\r\n        self.__stream.put(item)\r\n\r\n    def close(self):\r\n        self.__stream.put(None)\r\n\r\n    def duplicate(self):\r\n        ret = Stream()\r\n        ret.__stream.queue = self.__stream.queue.copy()\r\n        return ret\r\n\r\n    def get_item(self):\r\n        return self.__next__()\r\n\r\n    def count(self):\r\n        return self.__stream.qsize()\r\n\r\n    def first(self):\r\n        return self.__stream.queue[0]\r\n\r\n    def last(self):\r\n        x = self.__stream.queue[-1]\r\n        if x is None:  # if stream is closed last is None. We need the one before None.\r\n            x = self.__stream.queue[-2]\r\n        return x\r\n\r\n\r\ndef file_input(file_path: str, data_formatter: DataFormatter) -> Stream:\r\n    \"\"\"\r\n    Receives a file and returns a stream of events.\r\n    \"filepath\": the path to the file that is to be read.\r\n    The file will be parsed as so:\r\n    * Each line will be a different event\r\n    * Each line will be split on \",\" and the resulting array will be stored in an \"Event\",\r\n      and the keys are determined from the given list \"KeyMap\".\r\n    \"\"\"\r\n    with open(file_path, \"r\") as f:\r\n        content = f.readlines()\r\n    events = Stream()\r\n    for line in content:\r\n        events.add_item(Event(line, data_formatter))\r\n    events.close()\r\n    return events\r\n\r\n\r\ndef file_output(matches: list, output_file_name: str = 'matches.txt'):\r\n    \"\"\"\r\n    Writes output matches to a file in the subfolder \"Matches\".\r\n    It supports any iterable as output matches.\r\n    \"\"\"\r\n    with open(\"test/Matches/\" + output_file_name, 'w') as f:\r\n        for match in matches:\r\n            for event in match.events:\r\n                f.write(\"%s\\n\" % event.payload)\r\n            f.write(\"\\n\")\r\n\r\ndef EXPECTEDfile_output(matches: list, output_file_name: str = 'matches.txt'):\r\n    \"\"\"\r\n    Writes output matches to a file in the subfolder \"Matches\".\r\n    It supports any iterable as output matches.\r\n    \"\"\"\r\n    with open(\"test/TestsExpected/\" + output_file_name, 'w') as f:\r\n        for match in matches:\r\n            for event in match.events:\r\n                f.write(\"%s\\n\" % event.payload)\r\n            f.write(\"\\n\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- misc/IOUtils.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ misc/IOUtils.py	(date 1593954632238)
@@ -74,14 +74,3 @@
             for event in match.events:
                 f.write("%s\n" % event.payload)
             f.write("\n")
-
-def EXPECTEDfile_output(matches: list, output_file_name: str = 'matches.txt'):
-    """
-    Writes output matches to a file in the subfolder "Matches".
-    It supports any iterable as output matches.
-    """
-    with open("test/TestsExpected/" + output_file_name, 'w') as f:
-        for match in matches:
-            for event in match.events:
-                f.write("%s\n" % event.payload)
-            f.write("\n")
Index: test/tests.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nfrom CEP import CEP\r\nfrom evaluation.EvaluationMechanismFactory import EvaluationMechanismTypes, \\\r\n    IterativeImprovementEvaluationMechanismParameters\r\nfrom misc.IOUtils import file_input, file_output, EXPECTEDfile_output\r\nfrom misc.Stocks import MetastockDataFormatter\r\nfrom misc.Utils import generate_matches\r\nfrom evaluation.LeftDeepTreeBuilders import *\r\nfrom evaluation.BushyTreeBuilders import *\r\nfrom datetime import timedelta\r\nfrom base.Formula import GreaterThanFormula, SmallerThanFormula, SmallerThanEqFormula, GreaterThanEqFormula, MulTerm, \\\r\n    EqFormula, IdentifierTerm, AtomicTerm, AndFormula, TrueFormula\r\nfrom base.PatternStructure import AndOperator, SeqOperator, QItem, NegationOperator\r\nfrom base.Pattern import Pattern\r\n\r\nfrom Lib import filecmp\r\n\r\n\r\nnasdaqEventStreamShort = file_input(\"test/EventFiles/NASDAQ_SHORT.txt\", MetastockDataFormatter())\r\nnasdaqEventStreamHalfShort = file_input(\"test/EventFiles/NASDAQ_HALF_SHORT.txt\", MetastockDataFormatter())\r\nnasdaqEventStreamMedium = file_input(\"test/EventFiles/NASDAQ_MEDIUM.txt\", MetastockDataFormatter())\r\nnasdaqEventStreamFrequencyTailored = file_input(\"test/EventFiles/NASDAQ_FREQUENCY_TAILORED.txt\",\r\n                                                MetastockDataFormatter())\r\nnasdaqEventStream_AAPL_AMZN_GOOG = file_input(\"test/EventFiles/NASDAQ_AAPL_AMZN_GOOG.txt\", MetastockDataFormatter())\r\nnasdaqEventStream = file_input(\"test/EventFiles/NASDAQ_LONG.txt\", MetastockDataFormatter())\r\n\r\ncustom = file_input(\"test/EventFiles/custom.txt\", MetastockDataFormatter())\r\ncustom2 = file_input(\"test/EventFiles/custom2.txt\", MetastockDataFormatter())\r\nlonger = file_input(\"test/EventFiles/Longer.txt\", MetastockDataFormatter())\r\n\r\njustshort =  file_input(\"test/EventFiles/JustShort.txt\", MetastockDataFormatter())\r\n\r\ndef numOfLinesInPattern(file):\r\n    \"\"\"\r\n    get num of lines in file until first blank line == num of lines in pattern\r\n    :param file: file\r\n    :return: int\r\n    \"\"\"\r\n    counter = 0\r\n    for line in file:\r\n        if line == '\\n':\r\n            break\r\n        counter = counter + 1\r\n    return counter\r\n\r\n\r\ndef compareFiles(path1: str, path2: str):\r\n    \"\"\"\r\n    Compare expected output and actual ouput\r\n    :param path1: path to first file\r\n    :param path2: path to second file\r\n    :return: bool, True if the two files are equivalent\r\n    \"\"\"\r\n    file1 = open(path1)\r\n    file2 = open(path2)\r\n\r\n    counter1 = numOfLinesInPattern(file1)\r\n    counter2 = numOfLinesInPattern(file2)\r\n\r\n    file1.seek(0)\r\n    file2.seek(0)\r\n\r\n    # quick check, if both files don't return the same counter, or if both files are empty\r\n    if counter1 != counter2:\r\n        closeFiles(file1, file2)\r\n        print('dif counters')\r\n        return False\r\n    elif counter1 == counter2 and counter1 == 0:\r\n        closeFiles(file1, file2)\r\n        return True\r\n\r\n    set1 = set()\r\n    set2 = set()\r\n\r\n    fillSet(file1, set1, counter1)\r\n    fillSet(file2, set2, counter2)\r\n    closeFiles(file1, file2)\r\n\r\n    \"\"\"\r\n    with open('set1.txt', 'w') as f:\r\n        print(set1, file=f)\r\n\r\n    with open('set2.txt', 'w') as f:\r\n        print(set2, file=f)\r\n    \"\"\"\r\n    return set1 == set2\r\n\r\n\r\ndef fillSet(file, set: set, counter: int):\r\n    \"\"\"\r\n    fill a set, each element of the set is x consecutive lines of the file, with x = counter\r\n    :param file:\r\n    :param set:\r\n    :param counter:\r\n    :return:\r\n    \"\"\"\r\n    list = []\r\n    tmp = 0\r\n    for line in file:\r\n        if line == '\\n':\r\n            continue\r\n        # solve a problem when no blank lines at end of file\r\n        line = line.strip()\r\n        list.append(line)\r\n        tmp = tmp + 1\r\n        # if we read 'counter' lines, we want to add it to the set, and continue with the next 'counter' lines\r\n        if tmp == counter:\r\n            set.add(tuple(list))\r\n            list = []\r\n            tmp = 0\r\n\r\n\r\ndef closeFiles(file1, file2):\r\n    file1.close()\r\n    file2.close()\r\n\r\n\r\ndef fileCompare(pathA, pathB):\r\n    # return filecmp.cmp(pathA, pathB)\r\n\r\n    file1 = open(pathA)\r\n    file2 = open(pathB)\r\n\r\n    file1List = []  # List of unique patterns\r\n    file2List = []  # List of unique patterns\r\n    lineStack = \"\"\r\n    for line in file1:\r\n        if not line.strip():\r\n            lineStack += line\r\n        elif not (lineStack in file1List):\r\n            file1List.append(lineStack)\r\n            lineStack = \"\"\r\n    lineStack = \"\"\r\n    for line in file2:\r\n        if not line.strip():\r\n            lineStack += line\r\n        elif not (lineStack in file2List):\r\n            file2List.append(lineStack)\r\n            lineStack = \"\"\r\n    if len(file1List) != len(file2List):  # Fast check\r\n        closeFiles(file1, file2)\r\n        return False\r\n    for line in file1List:\r\n        if not (line in file2List):\r\n            closeFiles(file1, file2)\r\n            return False\r\n    for line in file2List:\r\n        if not (line in file1List):\r\n            closeFiles(file1, file2)\r\n            return False\r\n    closeFiles(file1, file2)\r\n    return True\r\n\r\n\r\ndef createTest(testName, patterns, events=None):\r\n    if events == None:\r\n        events = nasdaqEventStream.duplicate()\r\n    else:\r\n        events = events.duplicate()\r\n    pattern = patterns[0]\r\n    matches = generate_matches(pattern, events)\r\n    file_output(matches, '../TestsExpected/%sMatches.txt' % testName)\r\n    print(\"Finished creating test %s\" % testName)\r\n\r\n\r\ndef runTest(testName, patterns, createTestFile=False,\r\n            eval_mechanism_type=EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=None, events=None):\r\n    if createTestFile:\r\n        createTest(testName, patterns, events)\r\n    \"\"\"\r\n    if events is None:\r\n        events = nasdaqEventStream.duplicate()\r\n    else:\r\n        events = events.duplicate()\r\n    \"\"\"\r\n    # nathan\r\n    listShort = [\"OneNotBegin\", \"MultipleNotBegin\", \"MultipleNotMiddle\"]\r\n    listHalfShort = [\"OneNotEnd\", \"MultipleNotEnd\", \"DUMMYOneNotEnd\"]\r\n    listCustom = [\"MultipleNotBeginAndEnd\", \"DUMMYMultipleNotBeginAndEnd\"]\r\n    listCustom2 = [\"DUMMYsimpleNot\", \"simpleNot\"]\r\n    if testName in listShort:\r\n        events = nasdaqEventStreamShort.duplicate()\r\n    elif testName in listHalfShort:\r\n        events = nasdaqEventStreamHalfShort.duplicate()\r\n    elif testName in listCustom:\r\n        events = custom.duplicate()\r\n    elif testName in listCustom2:\r\n        events = custom2.duplicate()\r\n\r\n    #LongerEventStream = file_input(\"test/EventFiles/Longer.txt\", MetastockDataFormatter())\r\n    #events = longer.duplicate()\r\n    #testName = 'PROBLEM'\r\n\r\n    # events = justshort.duplicate()\r\n\r\n    cep = CEP(patterns, eval_mechanism_type, eval_mechanism_params)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    file_output(matches, '%sMatches.txt' % testName)\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % testName\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % testName\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (testName,\r\n                                                   \"Succeeded\" if compareFiles(actual_matches_path,\r\n                                                                               expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef oneArgumentsearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\")]),\r\n        GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]), AtomicTerm(135)),\r\n        timedelta.max\r\n    )\r\n    runTest(\"one\", [pattern], createTestFile)\r\n\r\n\r\ndef simplePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AVID\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"simple\", [pattern], createTestFile)\r\n\r\n\r\ndef googleAscendPatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for a short ascend in the Google peak prices.\r\n    PATTERN SEQ(GoogleStockPriceUpdate a, GoogleStockPriceUpdate b, GoogleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice\r\n    WITHIN 3 minutes\r\n    \"\"\"\r\n    googleAscendPattern = Pattern(\r\n        SeqOperator([QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    runTest('googleAscend', [googleAscendPattern], createTestFile)\r\n\r\n\r\ndef amazonInstablePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for an in-stable day for Amazon.\r\n    PATTERN SEQ(AmazonStockPriceUpdate x1, AmazonStockPriceUpdate x2, AmazonStockPriceUpdate x3)\r\n    WHERE x1.LowestPrice <= 75 AND x2.PeakPrice >= 78 AND x3.LowestPrice <= x1.LowestPrice\r\n    WITHIN 1 day\r\n    \"\"\"\r\n    amazonInstablePattern = Pattern(\r\n        SeqOperator([QItem(\"AMZN\", \"x1\"), QItem(\"AMZN\", \"x2\"), QItem(\"AMZN\", \"x3\")]),\r\n        AndFormula(\r\n            SmallerThanEqFormula(IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]), AtomicTerm(75)),\r\n            AndFormula(\r\n                GreaterThanEqFormula(IdentifierTerm(\"x2\", lambda x: x[\"Peak Price\"]), AtomicTerm(78)),\r\n                SmallerThanEqFormula(IdentifierTerm(\"x3\", lambda x: x[\"Lowest Price\"]),\r\n                                     IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]))\r\n            )\r\n        ),\r\n        timedelta(days=1)\r\n    )\r\n    runTest('amazonInstable', [amazonInstablePattern], createTestFile)\r\n\r\n\r\ndef msftDrivRacePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for a race between driv and microsoft in ten minutes\r\n    PATTERN SEQ(MicrosoftStockPriceUpdate a, DrivStockPriceUpdate b, MicrosoftStockPriceUpdate c, DrivStockPriceUpdate d, MicrosoftStockPriceUpdate e)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice AND c.PeakPrice < d.PeakPrice AND d.PeakPrice < e.PeakPrice\r\n    WITHIN 10 minutes\r\n    \"\"\"\r\n    msftDrivRacePattern = Pattern(\r\n        SeqOperator(\r\n            [QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"MSFT\", \"c\"), QItem(\"DRIV\", \"d\"), QItem(\"MSFT\", \"e\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"e\", lambda x: x[\"Peak Price\"]))\r\n            )\r\n        ),\r\n        timedelta(minutes=10)\r\n    )\r\n    runTest('msftDrivRace', [msftDrivRacePattern], createTestFile)\r\n\r\n\r\ndef googleIncreasePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This Pattern is looking for a 1% increase in the google stock in a half-hour.\r\n    PATTERN SEQ(GoogleStockPriceUpdate a, GoogleStockPriceUpdate b)\r\n    WHERE b.PeakPrice >= 1.01 * a.PeakPrice\r\n    WITHIN 30 minutes\r\n    \"\"\"\r\n    googleIncreasePattern = Pattern(\r\n        SeqOperator([QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\")]),\r\n        GreaterThanEqFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                             MulTerm(AtomicTerm(1.01), IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]))),\r\n        timedelta(minutes=30)\r\n    )\r\n    runTest('googleIncrease', [googleIncreasePattern], createTestFile)\r\n\r\n\r\ndef amazonSpecificPatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for an amazon stock in peak price of 73.\r\n    \"\"\"\r\n    amazonSpecificPattern = Pattern(\r\n        SeqOperator([QItem(\"AMZN\", \"a\")]),\r\n        EqFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), AtomicTerm(73))\r\n    )\r\n    runTest('amazonSpecific', [amazonSpecificPattern], createTestFile)\r\n\r\n\r\ndef googleAmazonLowPatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for low prices of Amazon and Google at the same minute.\r\n    PATTERN AND(AmazonStockPriceUpdate a, GoogleStockPriceUpdate g)\r\n    WHERE a.PeakPrice <= 73 AND g.PeakPrice <= 525\r\n    WITHIN 1 minute\r\n    \"\"\"\r\n    googleAmazonLowPattern = Pattern(\r\n        AndOperator([QItem(\"AMZN\", \"a\"), QItem(\"GOOG\", \"g\")]),\r\n        AndFormula(\r\n            SmallerThanEqFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]), AtomicTerm(73)),\r\n            SmallerThanEqFormula(IdentifierTerm(\"g\", lambda x: x[\"Peak Price\"]), AtomicTerm(525))\r\n        ),\r\n        timedelta(minutes=1)\r\n    )\r\n    runTest('googleAmazonLow', [googleAmazonLowPattern], createTestFile)\r\n\r\n\r\ndef nonsensePatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    This pattern is looking for something that does not make sense.\r\n    PATTERN AND(AmazonStockPriceUpdate a, AvidStockPriceUpdate b, AppleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice AND c.PeakPrice < a.PeakPrice\r\n    \"\"\"\r\n    nonsensePattern = Pattern(\r\n        AndOperator([QItem(\"AMZN\", \"a\"), QItem(\"AVID\", \"b\"), QItem(\"AAPL\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]))\r\n            )\r\n        ),\r\n        timedelta(minutes=1)\r\n    )\r\n    runTest('nonsense', [nonsensePattern], createTestFile)\r\n\r\n\r\ndef hierarchyPatternSearchTest(createTestFile=False):\r\n    \"\"\"\r\n    The following pattern is looking for Amazon < Apple < Google cases in one minute windows.\r\n    PATTERN AND(AmazonStockPriceUpdate a, AppleStockPriceUpdate b, GoogleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice\r\n    WITHIN 1 minute\r\n    \"\"\"\r\n    hierarchyPattern = Pattern(\r\n        AndOperator([QItem(\"AMZN\", \"a\"), QItem(\"AAPL\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=1)\r\n    )\r\n    runTest('hierarchy', [hierarchyPattern], createTestFile)\r\n\r\n\r\ndef multiplePatternSearchTest(createTestFile=False):\r\n    amazonInstablePattern = Pattern(\r\n        SeqOperator([QItem(\"AMZN\", \"x1\"), QItem(\"AMZN\", \"x2\"), QItem(\"AMZN\", \"x3\")]),\r\n        AndFormula(\r\n            SmallerThanEqFormula(IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]), AtomicTerm(75)),\r\n            AndFormula(\r\n                GreaterThanEqFormula(IdentifierTerm(\"x2\", lambda x: x[\"Peak Price\"]), AtomicTerm(78)),\r\n                SmallerThanEqFormula(IdentifierTerm(\"x3\", lambda x: x[\"Lowest Price\"]),\r\n                                     IdentifierTerm(\"x1\", lambda x: x[\"Lowest Price\"]))\r\n            )\r\n        ),\r\n        timedelta(days=1)\r\n    )\r\n    googleAscendPattern = Pattern(\r\n        SeqOperator([QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    runTest('multiplePatterns', [amazonInstablePattern, googleAscendPattern], createTestFile)\r\n\r\n\r\ndef nonFrequencyPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"LOCM\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"nonFrequency\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"LOCM\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 460, \"AMZN\": 442, \"LOCM\": 219})\r\n    runTest(\"frequency\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef arrivalRatesPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"LOCM\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.ARRIVAL_RATES, [0.0159, 0.0153, 0.0076])\r\n    runTest(\"arrivalRates\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef nonFrequencyPatternSearch2Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"LOCM\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AAPL\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"nonFrequency2\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearch2Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"LOCM\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AAPL\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 2, \"AMZN\": 3, \"LOCM\": 1})\r\n    runTest(\"frequency2\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef nonFrequencyPatternSearch3Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AAPL\", \"b\"), QItem(\"AAPL\", \"c\"), QItem(\"LOCM\", \"d\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"nonFrequency3\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearch3Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AAPL\", \"b\"), QItem(\"AAPL\", \"c\"), QItem(\"LOCM\", \"d\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 460, \"LOCM\": 219})\r\n    runTest(\"frequency3\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef nonFrequencyPatternSearch4Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AVID\", \"c\"), QItem(\"LOCM\", \"d\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    runTest(\"nonFrequency4\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearch4Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"AVID\", \"c\"), QItem(\"LOCM\", \"d\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AVID\": 1, \"LOCM\": 2, \"AAPL\": 3, \"AMZN\": 4})\r\n    runTest(\"frequency4\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef nonFrequencyPatternSearch5Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator(\r\n            [QItem(\"AAPL\", \"a1\"), QItem(\"LOCM\", \"b1\"), QItem(\"AAPL\", \"a2\"), QItem(\"LOCM\", \"b2\"), QItem(\"AAPL\", \"a3\"),\r\n             QItem(\"LOCM\", \"b3\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    runTest(\"nonFrequency5\", [pattern], createTestFile)\r\n\r\n\r\ndef frequencyPatternSearch5Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator(\r\n            [QItem(\"AAPL\", \"a1\"), QItem(\"LOCM\", \"b1\"), QItem(\"AAPL\", \"a2\"), QItem(\"LOCM\", \"b2\"), QItem(\"AAPL\", \"a3\"),\r\n             QItem(\"LOCM\", \"b3\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"LOCM\": 1, \"AAPL\": 2})  # {\"AAPL\": 460, \"LOCM\": 219}\r\n    runTest(\"frequency5\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef frequencyPatternSearch6Test(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator(\r\n            [QItem(\"AAPL\", \"a1\"), QItem(\"LOCM\", \"b1\"), QItem(\"AAPL\", \"a2\"), QItem(\"LOCM\", \"b2\"), QItem(\"AAPL\", \"a3\"),\r\n             QItem(\"LOCM\", \"b3\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=7)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"AAPL\": 1, \"LOCM\": 2})  # {\"AAPL\": 460, \"LOCM\": 219}\r\n    runTest(\"frequency6\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\ndef greedyPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('greedy1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.GREEDY_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef iiRandomPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiRandom1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.SWAP_BASED, IterativeImprovementInitType.RANDOM),\r\n            events=nasdaqEventStream)\r\n\r\n\r\ndef iiRandom2PatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiRandom2', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.CIRCLE_BASED, IterativeImprovementInitType.RANDOM),\r\n            events=nasdaqEventStream)\r\n\r\n\r\ndef iiGreedyPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiGreedy1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.SWAP_BASED, IterativeImprovementInitType.GREEDY),\r\n            events=nasdaqEventStream)\r\n\r\n\r\ndef iiGreedy2PatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('iiGreedy2', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE,\r\n            eval_mechanism_params=IterativeImprovementEvaluationMechanismParameters(\r\n                20, IterativeImprovementType.CIRCLE_BASED, IterativeImprovementInitType.GREEDY),\r\n            events=nasdaqEventStream)\r\n\r\n\r\ndef dpLdPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('dpLd1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.DYNAMIC_PROGRAMMING_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef dpBPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('dpB1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.DYNAMIC_PROGRAMMING_BUSHY_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef zStreamOrdPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('zstream-ord1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.ORDERED_ZSTREAM_BUSHY_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef zStreamPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"MSFT\", \"a\"), QItem(\"DRIV\", \"b\"), QItem(\"ORLY\", \"c\"), QItem(\"CBRL\", \"d\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n            ),\r\n            SmallerThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"d\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n    selectivityMatrix = [[1.0, 0.9457796098355941, 1.0, 1.0], [0.9457796098355941, 1.0, 0.15989723367389616, 1.0],\r\n                         [1.0, 0.15989723367389616, 1.0, 0.9992557393942864], [1.0, 1.0, 0.9992557393942864, 1.0]]\r\n    arrivalRates = [0.016597077244258872, 0.01454418928322895, 0.013917884481558803, 0.012421711899791231]\r\n    pattern.set_statistics(StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES, (selectivityMatrix, arrivalRates))\r\n    runTest('zstream1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.ZSTREAM_BUSHY_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef frequencyTailoredPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"DRIV\", \"a\"), QItem(\"MSFT\", \"b\"), QItem(\"CBRL\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    frequencyDict = {\"MSFT\": 256, \"DRIV\": 257, \"CBRL\": 1}\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, frequencyDict)\r\n    runTest('frequencyTailored1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef nonFrequencyTailoredPatternSearchTest(createTestFile=False):\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"DRIV\", \"a\"), QItem(\"MSFT\", \"b\"), QItem(\"CBRL\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    runTest('nonFrequencyTailored1', [pattern], createTestFile,\r\n            eval_mechanism_type=EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE, events=nasdaqEventStream)\r\n\r\n\r\ndef evaTest():\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), NegationOperator(QItem(\"GOOG\", \"c\"))]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            GreaterThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]), AtomicTerm(135))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/Problem.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    print('EVA_SUCCESS')\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    extraShort = 'extraShort'\r\n    file_output(matches, '%sMatches.txt' % extraShort)\r\n\r\n    expected_matches_path = \"test/TestsExpected/extraShortMatches.txt\"\r\n    actual_matches_path = \"test/Matches/extraShortMatches.txt\"\r\n\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (extraShort,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef NegAtTheBeginningThatDoesntInvalidatesMatchesTest():\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"AAPL\", \"a\")), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n            ),\r\n            GreaterThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]),\r\n                               AtomicTerm(35))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/JustShort.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'NegAtTheBeginningThatDoesntInvalidatesMatchesTest'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef googleAscendPatternSearchTestWITHNEG():\r\n    \"\"\"\r\n    This pattern is looking for a short ascend in the Google peak prices.\r\n    PATTERN SEQ(GoogleStockPriceUpdate a, GoogleStockPriceUpdate b, GoogleStockPriceUpdate c)\r\n    WHERE a.PeakPrice < b.PeakPrice AND b.PeakPrice < c.PeakPrice\r\n    WITHIN 3 minutes\r\n    \"\"\"\r\n    googleAscendPattern = Pattern(\r\n        SeqOperator(\r\n            [NegationOperator(QItem(\"GGGGG\", \"l\")), QItem(\"GOOG\", \"a\"), QItem(\"GOOG\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Peak Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Peak Price\"]))\r\n        ),\r\n        timedelta(minutes=3)\r\n    )\r\n\r\n    extraShortEventStream = file_input(\"test/EventFiles/NASDAQ_LONG.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([googleAscendPattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'googleAscend'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    os.remove(actual_matches_path)\r\n\r\n\r\ndef PROBLEM():\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), NegationOperator(QItem(\"AMZN\", \"b\")), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n            ),\r\n            GreaterThanFormula(IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]),\r\n                               AtomicTerm(35))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/PROBLEM.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'PROBLEM'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    # expected_matches = generate_matches(pattern, extraShortEventStream)\r\n    # EXPECTEDfile_output(expected_matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef MultipleNegTest():\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), NegationOperator(QItem(\"AMZN\", \"b\")), NegationOperator(QItem(\"AN\", \"f\")),\r\n                     NegationOperator(QItem(\"AllN\", \"m\")), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                SmallerThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))\r\n            ),\r\n            GreaterThanFormula(IdentifierTerm(\"f\", lambda x: x[\"Opening Price\"]),\r\n                               AtomicTerm(35))\r\n        ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/JustShort.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'MultipleNeg'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    # expected_matches = generate_matches(pattern, extraShortEventStream)\r\n    # EXPECTEDfile_output(expected_matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef OtherTest():\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"AAPL\", \"a\")), NegationOperator(QItem(\"AMZN\", \"b\")),\r\n                     QItem(\"GOOG\", \"c\"), QItem(\"G\", \"f\")]),\r\n        # SeqOperator([NegationOperator(QItem(\"AAPL\", \"a\")), QItem(\"AMZN\", \"b\"), NegationOperator(QItem(\"AllN\", \"m\")),\r\n        #             QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"AN\", \"f\")), NegationOperator(QItem(\"MMAN\", \"p\"))]),\r\n        AndFormula(SmallerThanFormula(IdentifierTerm(\"f\", lambda x: x[\"Opening Price\"]),\r\n                                      IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"])),\r\n                   SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                                      AtomicTerm(100))\r\n\r\n                   ),\r\n        timedelta.max\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/Longer.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'OtherTest'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    # expected_matches = generate_matches(pattern, extraShortEventStream)\r\n    # EXPECTEDfile_output(expected_matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\ndef OtherTestNat():\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"TYP1\", \"x\"))]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    extraShortEventStream = file_input(\"test/EventFiles/JustShort.txt\", MetastockDataFormatter())\r\n\r\n    events = extraShortEventStream.duplicate()\r\n    eval_mechanism_type = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE\r\n    cep = CEP([pattern], eval_mechanism_type)\r\n    running_time = cep.run(events)\r\n    matches = cep.get_pattern_match_stream()\r\n    name = 'OtherTestNat'\r\n    file_output(matches, '%sMatches.txt' % name)\r\n\r\n    # expected_matches = generate_matches(pattern, extraShortEventStream)\r\n    # EXPECTEDfile_output(expected_matches, '%sMatches.txt' % name)\r\n\r\n    expected_matches_path = \"test/TestsExpected/%sMatches.txt\" % name\r\n    actual_matches_path = \"test/Matches/%sMatches.txt\" % name\r\n    print(\"Test %s result: %s, Time Passed: %s\" % (name,\r\n                                                   \"Succeeded\" if fileCompare(actual_matches_path,\r\n                                                                              expected_matches_path) else \"Failed\",\r\n                                                   running_time))\r\n    # os.remove(actual_matches_path)\r\n\r\n\r\n# ON NASDAQ SHORT\r\ndef OneNotAtTheBeginningTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"TYP1\", \"x\")), QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"OneNotBegin\", [pattern], createTestFile)\r\n\r\n\r\n# ON NASDAQ SHORT\r\ndef MultipleNotAtTheBeginningTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"TYP1\", \"x\")), NegationOperator(QItem(\"TYP2\", \"y\")),\r\n                     NegationOperator(QItem(\"TYP3\", \"z\")), QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"MultipleNotBegin\", [pattern], createTestFile)\r\n\r\n\r\n# ON NASDAQ *HALF* SHORT\r\ndef OneNotAtTheEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"TYP1\", \"x\"))]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"OneNotEnd\", [pattern], createTestFile)\r\n\r\n# ON NASDAQ *HALF* SHORT\r\ndef DUMMYOneNotAtTheEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"DUMMYOneNotEnd\", [pattern], createTestFile)\r\n\r\n# ON NASDAQ *HALF* SHORT\r\ndef MultipleNotAtTheEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"TYP1\", \"x\")),\r\n                     NegationOperator(QItem(\"TYP2\", \"y\")), NegationOperator(QItem(\"TYP3\", \"z\"))]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"MultipleNotEnd\", [pattern], createTestFile)\r\n\r\n\r\n# ON CUSTOM\r\ndef MultipleNotBeginAndEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([NegationOperator(QItem(\"TYP1\", \"x\")),\r\n                     NegationOperator(QItem(\"TYP4\", \"t\")),\r\n                     QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"),\r\n                     QItem(\"GOOG\", \"c\"),\r\n                     NegationOperator(QItem(\"TYP2\", \"y\")),\r\n                     NegationOperator(QItem(\"TYP3\", \"z\"))]),\r\n        AndFormula(\r\n            AndFormula(\r\n                GreaterThanFormula(IdentifierTerm(\"x\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"y\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n            GreaterThanFormula(IdentifierTerm(\"t\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]))\r\n        ),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"MultipleNotBeginAndEnd\", [pattern], createTestFile)\r\n\r\n\r\n# ON CUSTOM\r\ndef DUMMYMultipleNotBeginAndEndTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"),\r\n                     QItem(\"GOOG\", \"c\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"DUMMYMultipleNotBeginAndEnd\", [pattern], createTestFile)\r\n\r\n\r\n\r\n# ON custom2\r\ndef simpleNotTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), NegationOperator(QItem(\"AMZN\", \"b\")), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"simpleNot\", [pattern], createTestFile)\r\n\r\n# ON custom2\r\ndef DUMMYsimpleNotTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"GOOG\", \"c\")]),\r\n        TrueFormula(),\r\n        timedelta(minutes=5)\r\n    )\r\n    runTest(\"DUMMYsimpleNot\", [pattern], createTestFile)\r\n\r\n\r\n# ON NASDAQ SHORT\r\ndef MultipleNotInTheMiddle(createTestFile=False):\r\n    \"\"\"\r\n        PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n        WHERE   a.OpeningPrice > b.OpeningPrice\r\n            AND b.OpeningPrice > c.OpeningPrice\r\n        WITHIN 5 minutes\r\n        \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), NegationOperator(QItem(\"LI\", \"d\")), QItem(\"AMZN\", \"b\"),\r\n                     NegationOperator(QItem(\"FB\", \"e\")), QItem(\"GOOG\", \"c\")]),\r\n        AndFormula(\r\n            AndFormula(\r\n                GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n            AndFormula(\r\n                GreaterThanFormula(IdentifierTerm(\"e\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"])),\r\n                SmallerThanFormula(IdentifierTerm(\"d\", lambda x: x[\"Opening Price\"]),\r\n                                   IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"])))\r\n            ),\r\n        timedelta(minutes=4)\r\n    )\r\n    runTest(\"MultipleNotMiddle\", [pattern], createTestFile)\r\n\r\n\r\n# ON NASDAQ *HALF* SHORT\r\ndef OneNotAtTheEndWithStatsTest(createTestFile=False):\r\n    \"\"\"\r\n    PATTERN SEQ(AppleStockPriceUpdate a, AmazonStockPriceUpdate b, AvidStockPriceUpdate c)\r\n    WHERE   a.OpeningPrice > b.OpeningPrice\r\n        AND b.OpeningPrice > c.OpeningPrice\r\n    WITHIN 5 minutes\r\n    \"\"\"\r\n    pattern = Pattern(\r\n        SeqOperator([QItem(\"AAPL\", \"a\"), QItem(\"AMZN\", \"b\"), QItem(\"GOOG\", \"c\"), NegationOperator(QItem(\"TYP1\", \"x\"))]),\r\n        AndFormula(\r\n            GreaterThanFormula(IdentifierTerm(\"a\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"])),\r\n            SmallerThanFormula(IdentifierTerm(\"b\", lambda x: x[\"Opening Price\"]),\r\n                               IdentifierTerm(\"c\", lambda x: x[\"Opening Price\"]))),\r\n        timedelta(minutes=5)\r\n    )\r\n    pattern.set_statistics(StatisticsTypes.FREQUENCY_DICT, {\"GOOG\": 1, \"AAPL\": 2, \"AMZN\": 3, \"TYP1\": 4})\r\n    runTest(\"OneNotEnd\", [pattern], createTestFile, EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE)\r\n\r\n\r\n# comment to commit and push\r\n# greedyPatternSearchTest()\r\n# evaTest()\r\n# NegAtTheBeginningThatDoesntInvalidatesMatchesTest()\r\n# googleAscendPatternSearchTestWITHNEG()\r\n# PROBLEM()\r\n# MultipleNegTest()\r\n\r\n\r\n# out = compareFiles('test/Matches/dpB1MatcheMatch.txt', 'test/Matches/dpB1MatchesExpect.txt')\r\n# print(out)\r\n\r\n#OtherTestNat()\r\n\r\n# nathan : a verifier !\r\nOneNotAtTheEndWithStatsTest()\r\n\r\n\r\nsimpleNotTest()\r\n\r\n# ON NASDAQ SHORT\r\nMultipleNotInTheMiddle()\r\nOneNotAtTheBeginningTest()\r\n\r\nMultipleNotAtTheBeginningTest()\r\n\r\n# ON NASDAQ HALF SHORT\r\nOneNotAtTheEndTest()\r\nMultipleNotAtTheEndTest()\r\n\r\n# ON CUSTOM\r\nMultipleNotBeginAndEndTest()\r\n\r\n# DUMMYPatternSearchTest_MultipleNotBeginAndEnd()\r\n\r\n\"\"\"\r\nOtherTest()\r\n\r\noneArgumentsearchTest()\r\nsimplePatternSearchTest()\r\ngoogleAscendPatternSearchTest()\r\namazonInstablePatternSearchTest()\r\nmsftDrivRacePatternSearchTest()\r\ngoogleIncreasePatternSearchTest()\r\namazonSpecificPatternSearchTest()\r\ngoogleAmazonLowPatternSearchTest()\r\nnonsensePatternSearchTest()\r\nhierarchyPatternSearchTest()\r\nnonFrequencyPatternSearchTest()\r\narrivalRatesPatternSearchTest()\r\nfrequencyPatternSearchTest()\r\nnonFrequencyPatternSearch2Test()\r\nfrequencyPatternSearch2Test()\r\nnonFrequencyPatternSearch3Test()\r\nfrequencyPatternSearch3Test()\r\nnonFrequencyPatternSearch4Test()\r\nfrequencyPatternSearch4Test()\r\nnonFrequencyPatternSearch5Test()\r\nfrequencyPatternSearch5Test()\r\nfrequencyPatternSearch6Test()\r\ngreedyPatternSearchTest()\r\niiRandomPatternSearchTest()\r\niiRandom2PatternSearchTest()\r\niiGreedyPatternSearchTest()\r\niiGreedy2PatternSearchTest()\r\n#zStreamOrdPatternSearchTest()\r\n#zStreamPatternSearchTest()\r\ndpBPatternSearchTest()\r\ndpLdPatternSearchTest()\r\nnonFrequencyTailoredPatternSearchTest()\r\nfrequencyTailoredPatternSearchTest()\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/tests.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ test/tests.py	(date 1593952297173)
@@ -1,7 +1,7 @@
 import os
 from CEP import CEP
 from evaluation.EvaluationMechanismFactory import EvaluationMechanismTypes, \
-    IterativeImprovementEvaluationMechanismParameters
+    IterativeImprovementEvaluationMechanismParameters, EvaluationMechanismParameters
 from misc.IOUtils import file_input, file_output, EXPECTEDfile_output
 from misc.Stocks import MetastockDataFormatter
 from misc.Utils import generate_matches
@@ -16,6 +16,8 @@
 from Lib import filecmp
 
 
+# com to commit
+
 nasdaqEventStreamShort = file_input("test/EventFiles/NASDAQ_SHORT.txt", MetastockDataFormatter())
 nasdaqEventStreamHalfShort = file_input("test/EventFiles/NASDAQ_HALF_SHORT.txt", MetastockDataFormatter())
 nasdaqEventStreamMedium = file_input("test/EventFiles/NASDAQ_MEDIUM.txt", MetastockDataFormatter())
@@ -165,7 +167,7 @@
 
 def runTest(testName, patterns, createTestFile=False,
             eval_mechanism_type=EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE,
-            eval_mechanism_params=None, events=None):
+            eval_mechanism_params=EvaluationMechanismParameters(), events=None):
     if createTestFile:
         createTest(testName, patterns, events)
     """
@@ -1324,9 +1326,9 @@
 
 # DUMMYPatternSearchTest_MultipleNotBeginAndEnd()
 
-"""
-OtherTest()
 
+#OtherTest()
+"""
 oneArgumentsearchTest()
 simplePatternSearchTest()
 googleAscendPatternSearchTest()
Index: base/Formula.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC  # Abstract Base Class\r\n\r\n\r\nclass Term(ABC):\r\n    \"\"\"\r\n    Evaluates to the term's value.\r\n    If there are variables (identifiers) in the term, a name-value binding shall be inputted.\r\n    \"\"\"\r\n    def eval(self, binding: dict = None):\r\n        raise NotImplementedError()\r\n\r\n    def get_term_of(self, names: set):\r\n        raise NotImplementedError()\r\n\r\n\r\nclass AtomicTerm(Term):\r\n    \"\"\"\r\n    An atomic term of a formula in a condition (e.g., in \"x*2 < y + 7\" the atomic terms are 2 and 7).\r\n    \"\"\"\r\n    def __init__(self, value: object):\r\n        self.value = value\r\n\r\n    def eval(self, binding: dict = None):\r\n        return self.value\r\n\r\n    def get_term_of(self, names: set):\r\n        return self\r\n\r\n\r\nclass IdentifierTerm(Term):\r\n    \"\"\"\r\n    A term of a formula representing a single variable (e.g., in \"x*2 < y + 7\" the atomic terms are x and y).\r\n    \"\"\"\r\n    def __init__(self, name: str, getattr_func: callable):\r\n        self.name = name\r\n        self.getattr_func = getattr_func\r\n\r\n    def eval(self, binding: dict = None):\r\n        if not type(binding) == dict or self.name not in binding:\r\n            raise NameError(\"Name %s is not bound to a value\" % self.name)\r\n        return self.getattr_func(binding[self.name])\r\n\r\n    def get_term_of(self, names: set):\r\n        if self.name in names:\r\n            return self\r\n        return None\r\n\r\n\r\n\r\nclass BinaryOperationTerm(Term):\r\n    \"\"\"\r\n    A term representing a binary operation.\r\n    \"\"\"\r\n    def __init__(self, lhs: Term, rhs: Term, binary_op: callable):\r\n        self.lhs = lhs\r\n        self.rhs = rhs\r\n        self.binary_op = binary_op\r\n\r\n    def eval(self, binding: dict = None):\r\n        return self.binary_op(self.lhs.eval(binding), self.rhs.eval(binding))\r\n\r\n    def get_term_of(self, names: set):\r\n        raise NotImplementedError()\r\n\r\n\r\nclass PlusTerm(BinaryOperationTerm):\r\n    def __init__(self, lhs: Term, rhs: Term):\r\n        super().__init__(lhs, rhs, lambda x, y: x + y)\r\n\r\n    def get_term_of(self, names: set):\r\n        lhs = self.lhs.get_term_of(names)\r\n        rhs = self.rhs.get_term_of(names)\r\n        if lhs and rhs:\r\n            return PlusTerm(lhs, rhs)\r\n        return None\r\n\r\n\r\nclass MinusTerm(BinaryOperationTerm):\r\n    def __init__(self, lhs: Term, rhs: Term):\r\n        super().__init__(lhs, rhs, lambda x, y: x - y)\r\n\r\n    def get_term_of(self, names: set):\r\n        lhs = self.lhs.get_term_of(names)\r\n        rhs = self.rhs.get_term_of(names)\r\n        if lhs and rhs:\r\n            return MinusTerm(lhs, rhs)\r\n        return None\r\n\r\n\r\nclass MulTerm(BinaryOperationTerm):\r\n    def __init__(self, lhs: Term, rhs: Term):\r\n        super().__init__(lhs, rhs, lambda x, y: x * y)\r\n\r\n    def get_term_of(self, names: set):\r\n        lhs = self.lhs.get_term_of(names)\r\n        rhs = self.rhs.get_term_of(names)\r\n        if lhs and rhs:\r\n            return MulTerm(lhs, rhs)\r\n        return None\r\n\r\n\r\nclass DivTerm(BinaryOperationTerm):\r\n    def __init__(self, lhs: Term, rhs: Term):\r\n        super().__init__(lhs, rhs, lambda x, y: x / y)\r\n\r\n    def get_term_of(self, names: set):\r\n        lhs = self.lhs.get_term_of(names)\r\n        rhs = self.rhs.get_term_of(names)\r\n        if lhs and rhs:\r\n            return DivTerm(lhs, rhs)\r\n        return None\r\n\r\n\r\nclass Formula(ABC):\r\n    \"\"\"\r\n    Returns whether the parameters satisfy the formula. It evaluates to True or False.\r\n    If there are variables (identifiers) in the formula, a name-value binding shall be inputted.\r\n    \"\"\"\r\n    def eval(self, binding: dict = None):\r\n        pass\r\n\r\n    def get_formula_of(self, names: set):\r\n        pass\r\n\r\n    #17.06\r\n    def get_all_terms(self, term_set: set):\r\n        NotImplementedError()\r\n\r\n\r\nclass AtomicFormula(Formula):\r\n    \"\"\"\r\n    An atomic formula containing no logic operators (e.g., A < B).\r\n    \"\"\"\r\n    def __init__(self, left_term: Term, right_term: Term, relation_op: callable):\r\n        self.left_term = left_term\r\n        self.right_term = right_term\r\n        self.relation_op = relation_op\r\n\r\n    def eval(self, binding: dict = None):\r\n        return self.relation_op(self.left_term.eval(binding), self.right_term.eval(binding))\r\n\r\n    def get_all_terms(self, term_set: set):\r\n        if type(self.left_term) == IdentifierTerm:\r\n            term_set.add(self.left_term.name)\r\n        if type(self.right_term) == IdentifierTerm:\r\n            term_set.add(self.right_term.name)\r\n        return term_set\r\n\r\n\r\n\r\nclass EqFormula(AtomicFormula):\r\n    def __init__(self, left_term: Term, right_term: Term):\r\n        super().__init__(left_term, right_term, lambda x, y: x == y)\r\n\r\n    def get_formula_of(self, names: set):\r\n        right_term = self.right_term.get_term_of(names)\r\n        left_term = self.left_term.get_term_of(names)\r\n        if left_term and right_term:\r\n            return EqFormula(left_term, right_term)\r\n        return None\r\n\r\n    def get_events_in_a_condition_with(self, name: str):\r\n        right_term = self.right_term\r\n        left_term = self.left_term\r\n        if left_term is None or right_term is None:\r\n            return None\r\n        if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:\r\n            return None\r\n        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:\r\n            return EqFormula(left_term, right_term)\r\n        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:\r\n            return EqFormula(left_term, right_term)\r\n        return None\r\n\r\n\r\nclass NotEqFormula(AtomicFormula):\r\n    def __init__(self, left_term: Term, right_term: Term):\r\n        super().__init__(left_term, right_term, lambda x, y: x != y)\r\n\r\n    def get_formula_of(self, names: set):\r\n        right_term = self.right_term.get_term_of(names)\r\n        left_term = self.left_term.get_term_of(names)\r\n        if left_term and right_term:\r\n            return NotEqFormula(left_term, right_term)\r\n        return None\r\n\r\n    def get_events_in_a_condition_with(self, name: str):\r\n        right_term = self.right_term\r\n        left_term = self.left_term\r\n        if left_term is None or right_term is None:\r\n            return None\r\n        if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:\r\n            return None\r\n        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:\r\n            return NotEqFormula(left_term, right_term)\r\n        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:\r\n            return NotEqFormula(left_term, right_term)\r\n        return None\r\n\r\nclass GreaterThanFormula(AtomicFormula):\r\n    def __init__(self, left_term: Term, right_term: Term):\r\n        super().__init__(left_term, right_term, lambda x, y: x > y)\r\n\r\n    def get_formula_of(self, names: set):\r\n        right_term = self.right_term.get_term_of(names)\r\n        left_term = self.left_term.get_term_of(names)\r\n        if left_term and right_term:\r\n            return GreaterThanFormula(left_term, right_term)\r\n        return None\r\n\r\n    def get_events_in_a_condition_with(self, name: str):\r\n        right_term = self.right_term\r\n        left_term = self.left_term\r\n        if left_term is None or right_term is None:\r\n            return None\r\n        if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:\r\n            return None\r\n        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:\r\n            return GreaterThanFormula(left_term, right_term)\r\n        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:\r\n            return GreaterThanFormula(left_term, right_term)\r\n        return None\r\n\r\nclass SmallerThanFormula(AtomicFormula):\r\n    def __init__(self, left_term: Term, right_term: Term):\r\n        super().__init__(left_term, right_term, lambda x, y: x < y)\r\n\r\n    def get_formula_of(self, names: set):\r\n        right_term = self.right_term.get_term_of(names)\r\n        left_term = self.left_term.get_term_of(names)\r\n        if left_term and right_term:\r\n            return SmallerThanFormula(left_term, right_term)\r\n        return None\r\n\r\n    def get_events_in_a_condition_with(self, name: str):\r\n        right_term = self.right_term\r\n        left_term = self.left_term\r\n        if left_term is None or right_term is None:\r\n            return None\r\n        if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:\r\n            return None\r\n        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:\r\n            return SmallerThanFormula(left_term, right_term)\r\n        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:\r\n            return SmallerThanFormula(left_term, right_term)\r\n        return None\r\n\r\nclass GreaterThanEqFormula(AtomicFormula):\r\n    def __init__(self, left_term: Term, right_term: Term):\r\n        super().__init__(left_term, right_term, lambda x, y: x >= y)\r\n\r\n    def get_formula_of(self, names: set):\r\n        right_term = self.right_term.get_term_of(names)\r\n        left_term = self.left_term.get_term_of(names)\r\n        if left_term and right_term:\r\n            return GreaterThanEqFormula(left_term, right_term)\r\n        return None\r\n\r\n    def get_events_in_a_condition_with(self, name: str):\r\n        right_term = self.right_term\r\n        left_term = self.left_term\r\n        if left_term is None or right_term is None:\r\n            return None\r\n        if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:\r\n            return None\r\n        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:\r\n            return GreaterThanEqFormula(left_term, right_term)\r\n        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:\r\n            return GreaterThanEqFormula(left_term, right_term)\r\n        return None\r\n\r\nclass SmallerThanEqFormula(AtomicFormula):\r\n    def __init__(self, left_term: Term, right_term: Term):\r\n        super().__init__(left_term, right_term, lambda x, y: x <= y)\r\n\r\n    def get_formula_of(self, names: set):\r\n        right_term = self.right_term.get_term_of(names)\r\n        left_term = self.left_term.get_term_of(names)\r\n        if left_term and right_term:\r\n            return SmallerThanEqFormula(left_term, right_term)\r\n        return None\r\n\r\n    def get_events_in_a_condition_with(self, name: str):\r\n        right_term = self.right_term\r\n        left_term = self.left_term\r\n        if left_term is None or right_term is None:\r\n            return None\r\n        if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:\r\n            return None\r\n        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:\r\n            return SmallerThanEqFormula(left_term, right_term)\r\n        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:\r\n            return SmallerThanEqFormula(left_term, right_term)\r\n        return None\r\n\r\nclass BinaryLogicOpFormula(Formula):\r\n    \"\"\"\r\n    A formula composed of a logic operator and two nested formulas.\r\n    \"\"\"\r\n    def __init__(self, left_formula: Formula, right_formula: Formula, binary_logic_op: callable):\r\n        self.left_formula = left_formula\r\n        self.right_formula = right_formula\r\n        self.binary_logic_op = binary_logic_op\r\n\r\n    def eval(self, binding: dict = None):\r\n        return self.binary_logic_op(self.left_formula.eval(binding), self.right_formula.eval(binding))\r\n\r\n    def get_all_terms(self, term_set: set):\r\n        self.left_formula.get_all_terms(term_set)\r\n        self.right_formula.get_all_terms(term_set)\r\n        return term_set\r\n\r\n\r\n\r\nclass AndFormula(BinaryLogicOpFormula):\r\n    def __init__(self, left_formula: Formula, right_formula: Formula):\r\n        super().__init__(left_formula, right_formula, lambda x, y: x and y)\r\n\r\n    def get_formula_of(self, names: set):\r\n        right_formula = self.right_formula.get_formula_of(names)\r\n        left_formula = self.left_formula.get_formula_of(names)\r\n        if left_formula is not None and right_formula is not None:\r\n            return AndFormula(left_formula, right_formula)\r\n        if left_formula:\r\n            return left_formula\r\n        if right_formula:\r\n            return right_formula\r\n        return None\r\n\r\n    def get_events_in_a_condition_with(self, name: str):\r\n        right_formula = self.right_formula.get_events_in_a_condition_with(name)\r\n        left_formula = self.left_formula.get_events_in_a_condition_with(name)\r\n        if left_formula is not None and right_formula is not None:\r\n            return AndFormula(left_formula, right_formula)\r\n        if left_formula:\r\n            return left_formula\r\n        if right_formula:\r\n            return right_formula\r\n        return None\r\n\r\nclass TrueFormula(Formula):\r\n    def eval(self, binding: dict = None):\r\n        return True\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- base/Formula.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ base/Formula.py	(date 1593953679188)
@@ -43,7 +43,6 @@
     def get_term_of(self, names: set):
         if self.name in names:
             return self
-        return None
 
 
 
@@ -72,7 +71,6 @@
         rhs = self.rhs.get_term_of(names)
         if lhs and rhs:
             return PlusTerm(lhs, rhs)
-        return None
 
 
 class MinusTerm(BinaryOperationTerm):
@@ -84,7 +82,6 @@
         rhs = self.rhs.get_term_of(names)
         if lhs and rhs:
             return MinusTerm(lhs, rhs)
-        return None
 
 
 class MulTerm(BinaryOperationTerm):
@@ -96,7 +93,6 @@
         rhs = self.rhs.get_term_of(names)
         if lhs and rhs:
             return MulTerm(lhs, rhs)
-        return None
 
 
 class DivTerm(BinaryOperationTerm):
@@ -108,7 +104,6 @@
         rhs = self.rhs.get_term_of(names)
         if lhs and rhs:
             return DivTerm(lhs, rhs)
-        return None
 
 
 class Formula(ABC):
@@ -122,7 +117,6 @@
     def get_formula_of(self, names: set):
         pass
 
-    #17.06
     def get_all_terms(self, term_set: set):
         NotImplementedError()
 
@@ -157,7 +151,6 @@
         left_term = self.left_term.get_term_of(names)
         if left_term and right_term:
             return EqFormula(left_term, right_term)
-        return None
 
     def get_events_in_a_condition_with(self, name: str):
         right_term = self.right_term
@@ -166,11 +159,10 @@
             return None
         if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:
             return None
-        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:
+        if type(left_term) == IdentifierTerm and left_term.name == name:
             return EqFormula(left_term, right_term)
-        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:
+        if type(right_term) == IdentifierTerm and right_term.name == name:
             return EqFormula(left_term, right_term)
-        return None
 
 
 class NotEqFormula(AtomicFormula):
@@ -182,7 +174,6 @@
         left_term = self.left_term.get_term_of(names)
         if left_term and right_term:
             return NotEqFormula(left_term, right_term)
-        return None
 
     def get_events_in_a_condition_with(self, name: str):
         right_term = self.right_term
@@ -191,11 +182,10 @@
             return None
         if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:
             return None
-        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:
+        if type(left_term) == IdentifierTerm and left_term.name == name:
             return NotEqFormula(left_term, right_term)
-        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:
+        if type(right_term) == IdentifierTerm and right_term.name == name:
             return NotEqFormula(left_term, right_term)
-        return None
 
 class GreaterThanFormula(AtomicFormula):
     def __init__(self, left_term: Term, right_term: Term):
@@ -206,7 +196,6 @@
         left_term = self.left_term.get_term_of(names)
         if left_term and right_term:
             return GreaterThanFormula(left_term, right_term)
-        return None
 
     def get_events_in_a_condition_with(self, name: str):
         right_term = self.right_term
@@ -215,11 +204,10 @@
             return None
         if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:
             return None
-        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:
+        if type(left_term) == IdentifierTerm and left_term.name == name:
             return GreaterThanFormula(left_term, right_term)
-        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:
+        if type(right_term) == IdentifierTerm and right_term.name == name:
             return GreaterThanFormula(left_term, right_term)
-        return None
 
 class SmallerThanFormula(AtomicFormula):
     def __init__(self, left_term: Term, right_term: Term):
@@ -230,7 +218,6 @@
         left_term = self.left_term.get_term_of(names)
         if left_term and right_term:
             return SmallerThanFormula(left_term, right_term)
-        return None
 
     def get_events_in_a_condition_with(self, name: str):
         right_term = self.right_term
@@ -239,11 +226,10 @@
             return None
         if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:
             return None
-        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:
+        if type(left_term) == IdentifierTerm and left_term.name == name:
             return SmallerThanFormula(left_term, right_term)
-        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:
+        if type(right_term) == IdentifierTerm and right_term.name == name:
             return SmallerThanFormula(left_term, right_term)
-        return None
 
 class GreaterThanEqFormula(AtomicFormula):
     def __init__(self, left_term: Term, right_term: Term):
@@ -254,7 +240,6 @@
         left_term = self.left_term.get_term_of(names)
         if left_term and right_term:
             return GreaterThanEqFormula(left_term, right_term)
-        return None
 
     def get_events_in_a_condition_with(self, name: str):
         right_term = self.right_term
@@ -263,11 +248,10 @@
             return None
         if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:
             return None
-        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:
+        if type(left_term) == IdentifierTerm and left_term.name == name:
             return GreaterThanEqFormula(left_term, right_term)
-        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:
+        if type(right_term) == IdentifierTerm and right_term.name == name:
             return GreaterThanEqFormula(left_term, right_term)
-        return None
 
 class SmallerThanEqFormula(AtomicFormula):
     def __init__(self, left_term: Term, right_term: Term):
@@ -278,7 +262,6 @@
         left_term = self.left_term.get_term_of(names)
         if left_term and right_term:
             return SmallerThanEqFormula(left_term, right_term)
-        return None
 
     def get_events_in_a_condition_with(self, name: str):
         right_term = self.right_term
@@ -287,11 +270,10 @@
             return None
         if type(left_term) != IdentifierTerm or type(right_term) != IdentifierTerm:
             return None
-        if left_term is not None and type(left_term) == IdentifierTerm and left_term.name == name:
+        if type(left_term) == IdentifierTerm and left_term.name == name:
             return SmallerThanEqFormula(left_term, right_term)
-        if right_term is not None and type(right_term) == IdentifierTerm and right_term.name == name:
+        if type(right_term) == IdentifierTerm and right_term.name == name:
             return SmallerThanEqFormula(left_term, right_term)
-        return None
 
 class BinaryLogicOpFormula(Formula):
     """
@@ -325,7 +307,6 @@
             return left_formula
         if right_formula:
             return right_formula
-        return None
 
     def get_events_in_a_condition_with(self, name: str):
         right_formula = self.right_formula.get_events_in_a_condition_with(name)
@@ -336,7 +317,6 @@
             return left_formula
         if right_formula:
             return right_formula
-        return None
 
 class TrueFormula(Formula):
     def eval(self, binding: dict = None):
Index: evaluation/EvaluationMechanismFactory.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import List\r\nfrom enum import Enum\r\n\r\nfrom base.Pattern import Pattern\r\nfrom evaluation.BushyTreeBuilders import DynamicProgrammingBushyTreeBuilder, ZStreamTreeBuilder, ZStreamOrdTreeBuilder\r\nfrom evaluation.IterativeImprovement import IterativeImprovementType\r\nfrom evaluation.LeftDeepTreeBuilders import IterativeImprovementInitType, TrivialLeftDeepTreeBuilder, \\\r\n    AscendingFrequencyTreeBuilder, GreedyLeftDeepTreeBuilder, IterativeImprovementLeftDeepTreeBuilder, \\\r\n    DynamicProgrammingLeftDeepTreeBuilder\r\n\r\n\r\nclass EvaluationMechanismTypes(Enum):\r\n    \"\"\"\r\n    The various algorithms for constructing an efficient evaluation tree.\r\n    \"\"\"\r\n    TRIVIAL_LEFT_DEEP_TREE = 0,\r\n    SORT_BY_FREQUENCY_LEFT_DEEP_TREE = 1,\r\n    GREEDY_LEFT_DEEP_TREE = 2,\r\n    LOCAL_SEARCH_LEFT_DEEP_TREE = 3,\r\n    DYNAMIC_PROGRAMMING_LEFT_DEEP_TREE = 4,\r\n    DYNAMIC_PROGRAMMING_BUSHY_TREE = 5,\r\n    ZSTREAM_BUSHY_TREE = 6,\r\n    ORDERED_ZSTREAM_BUSHY_TREE = 7\r\n\r\n\r\nclass EvaluationMechanismParameters:\r\n    \"\"\"\r\n    Parameters for the evaluation mechanism builder.\r\n    \"\"\"\r\n    def __init__(self, eval_mechanism_type: EvaluationMechanismTypes):\r\n        self.type = eval_mechanism_type\r\n\r\n\r\nclass IterativeImprovementEvaluationMechanismParameters(EvaluationMechanismParameters):\r\n    \"\"\"\r\n    Parameters for evaluation mechanism builders based on local search include the number of search steps, the\r\n    choice of the neighborhood (step) function, and the way to generate the initial state.\r\n    \"\"\"\r\n    def __init__(self, step_limit: int,\r\n                 ii_type: IterativeImprovementType = IterativeImprovementType.SWAP_BASED,\r\n                 init_type: IterativeImprovementInitType = IterativeImprovementInitType.RANDOM):\r\n        super().__init__(EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE)\r\n        self.ii_type = ii_type\r\n        self.init_type = init_type\r\n        self.step_limit = step_limit\r\n\r\n\r\nclass EvaluationMechanismFactory:\r\n    \"\"\"\r\n    Creates an evaluation mechanism given its specification.\r\n    \"\"\"\r\n    @staticmethod\r\n    def build_single_pattern_eval_mechanism(eval_mechanism_type: EvaluationMechanismTypes,\r\n                                            eval_mechanism_params: EvaluationMechanismParameters,\r\n                                            pattern: Pattern):\r\n        return EvaluationMechanismFactory. \\\r\n            __create_eval_mechanism_builder(eval_mechanism_type, eval_mechanism_params). \\\r\n            build_single_pattern_eval_mechanism(pattern)\r\n\r\n    @staticmethod\r\n    def build_multi_pattern_eval_mechanism(eval_mechanism_type: EvaluationMechanismTypes,\r\n                                           eval_mechanism_params: EvaluationMechanismParameters,\r\n                                           patterns: List[Pattern]):\r\n        return EvaluationMechanismFactory. \\\r\n            __create_eval_mechanism_builder(eval_mechanism_type, eval_mechanism_params). \\\r\n            build_multi_pattern_eval_mechanism(patterns)\r\n\r\n    @staticmethod\r\n    def __create_eval_mechanism_builder(eval_mechanism_type: EvaluationMechanismTypes,\r\n                                        eval_mechanism_params: EvaluationMechanismParameters):\r\n        eval_mechanism_params = EvaluationMechanismFactory.__create_eval_mechanism_parameters(eval_mechanism_type,\r\n                                                                                              eval_mechanism_params)\r\n        if eval_mechanism_params.type == EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE:\r\n            return TrivialLeftDeepTreeBuilder()\r\n        if eval_mechanism_params.type == EvaluationMechanismTypes.SORT_BY_FREQUENCY_LEFT_DEEP_TREE:\r\n            return AscendingFrequencyTreeBuilder()\r\n        if eval_mechanism_params.type == EvaluationMechanismTypes.GREEDY_LEFT_DEEP_TREE:\r\n            return GreedyLeftDeepTreeBuilder()\r\n        if eval_mechanism_params.type == EvaluationMechanismTypes.LOCAL_SEARCH_LEFT_DEEP_TREE:\r\n            return IterativeImprovementLeftDeepTreeBuilder(eval_mechanism_params.step_limit,\r\n                                                           eval_mechanism_params.ii_type,\r\n                                                           eval_mechanism_params.init_type)\r\n        if eval_mechanism_params.type == EvaluationMechanismTypes.DYNAMIC_PROGRAMMING_LEFT_DEEP_TREE:\r\n            return DynamicProgrammingLeftDeepTreeBuilder()\r\n        if eval_mechanism_params.type == EvaluationMechanismTypes.DYNAMIC_PROGRAMMING_BUSHY_TREE:\r\n            return DynamicProgrammingBushyTreeBuilder()\r\n        if eval_mechanism_params.type == EvaluationMechanismTypes.ZSTREAM_BUSHY_TREE:\r\n            return ZStreamTreeBuilder()\r\n        if eval_mechanism_params.type == EvaluationMechanismTypes.ORDERED_ZSTREAM_BUSHY_TREE:\r\n            return ZStreamOrdTreeBuilder()\r\n        return None\r\n\r\n    @staticmethod\r\n    def __create_eval_mechanism_parameters(eval_mechanism_type: EvaluationMechanismTypes,\r\n                                           eval_mechanism_params: EvaluationMechanismParameters):\r\n        if eval_mechanism_params is not None:\r\n            return eval_mechanism_params\r\n        return EvaluationMechanismParameters(eval_mechanism_type)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- evaluation/EvaluationMechanismFactory.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ evaluation/EvaluationMechanismFactory.py	(date 1593952788504)
@@ -7,6 +7,7 @@
 from evaluation.LeftDeepTreeBuilders import IterativeImprovementInitType, TrivialLeftDeepTreeBuilder, \
     AscendingFrequencyTreeBuilder, GreedyLeftDeepTreeBuilder, IterativeImprovementLeftDeepTreeBuilder, \
     DynamicProgrammingLeftDeepTreeBuilder
+from evaluation.EvaluationMechanism import NegationMode
 
 
 class EvaluationMechanismTypes(Enum):
@@ -26,9 +27,12 @@
 class EvaluationMechanismParameters:
     """
     Parameters for the evaluation mechanism builder.
+
     """
-    def __init__(self, eval_mechanism_type: EvaluationMechanismTypes):
+    def __init__(self, eval_mechanism_type: EvaluationMechanismTypes = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE,
+                 negation_mode: NegationMode = NegationMode.POST_PROCESSING):
         self.type = eval_mechanism_type
+        self.negation_mode = negation_mode
 
 
 class IterativeImprovementEvaluationMechanismParameters(EvaluationMechanismParameters):
@@ -55,7 +59,7 @@
                                             pattern: Pattern):
         return EvaluationMechanismFactory. \
             __create_eval_mechanism_builder(eval_mechanism_type, eval_mechanism_params). \
-            build_single_pattern_eval_mechanism(pattern)
+            build_single_pattern_eval_mechanism(pattern, eval_mechanism_params)
 
     @staticmethod
     def build_multi_pattern_eval_mechanism(eval_mechanism_type: EvaluationMechanismTypes,
Index: evaluation/EvaluationMechanism.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC\r\nfrom misc.IOUtils import Stream\r\n\r\n\r\nclass EvaluationMechanism(ABC):\r\n    \"\"\"\r\n    Every evaluation mechanism must inherit from this class and implement the 'eval' function, receiving an input\r\n    stream of events and putting the detected pattern matches into a given output stream.\r\n    \"\"\"\r\n    def eval(self, events: Stream, matches: Stream):\r\n        pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- evaluation/EvaluationMechanism.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ evaluation/EvaluationMechanism.py	(date 1593952734219)
@@ -1,5 +1,6 @@
 from abc import ABC
 from misc.IOUtils import Stream
+from enum import Enum
 
 
 class EvaluationMechanism(ABC):
@@ -9,3 +10,9 @@
     """
     def eval(self, events: Stream, matches: Stream):
         pass
+
+class NegationMode(Enum):
+
+    POST_PROCESSING = 0,
+    FIRST_CHANCE = 1
+
Index: evaluation/EvaluationMechanismBuilder.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC\r\nfrom typing import List\r\n\r\nfrom base.Pattern import Pattern\r\n\r\n\r\nclass EvaluationMechanismBuilder(ABC):\r\n    \"\"\"\r\n    A generic class for creating an evaluation mechanism out of the given pattern specifications\r\n    and/or other parameters.\r\n    \"\"\"\r\n    def build_single_pattern_eval_mechanism(self, pattern: Pattern):\r\n        pass\r\n\r\n    def build_multi_pattern_eval_mechanism(self, patterns: List[Pattern]):\r\n        pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- evaluation/EvaluationMechanismBuilder.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ evaluation/EvaluationMechanismBuilder.py	(date 1593951537119)
@@ -9,7 +9,7 @@
     A generic class for creating an evaluation mechanism out of the given pattern specifications
     and/or other parameters.
     """
-    def build_single_pattern_eval_mechanism(self, pattern: Pattern):
+    def build_single_pattern_eval_mechanism(self, pattern: Pattern, eval_mechanism_params):
         pass
 
     def build_multi_pattern_eval_mechanism(self, patterns: List[Pattern]):
Index: evaluation/TreeBasedEvaluationMechanism.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from abc import ABC\r\nfrom datetime import timedelta, datetime\r\nfrom base.Pattern import Pattern\r\nfrom base.PatternStructure import SeqOperator, QItem, NegationOperator, AndOperator, OrOperator\r\nfrom base.Formula import TrueFormula, Formula\r\nfrom evaluation.PartialMatch import PartialMatch\r\nfrom misc.IOUtils import Stream\r\nfrom typing import List, Tuple\r\nfrom base.Event import Event\r\nfrom misc.Utils import merge, merge_according_to, is_sorted, find_partial_match_by_timestamp, get_index, \\\r\n    find_positive_events_before\r\nfrom base.PatternMatch import PatternMatch\r\nfrom evaluation.EvaluationMechanism import EvaluationMechanism\r\nfrom queue import Queue\r\n\r\n# check_expired_timestamp = set()\r\n\r\nclass Node(ABC):\r\n    \"\"\"\r\n    This class represents a single node of an evaluation tree.\r\n    \"\"\"\r\n\r\n    def __init__(self, sliding_window: timedelta, parent):\r\n        self._parent = parent\r\n        self._sliding_window = sliding_window\r\n        self._partial_matches = []\r\n        self._condition = TrueFormula()\r\n        # matches that were not yet pushed to the parent for further processing\r\n        self._unhandled_partial_matches = Queue()\r\n\r\n    def consume_first_partial_match(self):\r\n        \"\"\"\r\n        Removes and returns a single partial match buffered at this node.\r\n        Used in the root node to collect full pattern matches.\r\n        \"\"\"\r\n        ret = self._partial_matches[0]\r\n        del self._partial_matches[0]\r\n        return ret\r\n\r\n    def has_partial_matches(self):\r\n        \"\"\"\r\n        Returns True if this node contains any partial matches and False otherwise.\r\n        \"\"\"\r\n        return len(self._partial_matches) > 0\r\n\r\n    def get_last_unhandled_partial_match(self):\r\n        \"\"\"\r\n        Returns the last partial match buffered at this node and not yet transferred to its parent.\r\n        \"\"\"\r\n        return self._unhandled_partial_matches.get()\r\n\r\n    def set_parent(self, parent):\r\n        \"\"\"\r\n        Sets the parent of this node.\r\n        \"\"\"\r\n        self._parent = parent\r\n\r\n    def clean_expired_partial_matches(self, last_timestamp: datetime):\r\n        \"\"\"\r\n        Removes partial matches whose earliest timestamp violates the time window constraint.\r\n        \"\"\"\r\n        if self._sliding_window == timedelta.max:\r\n            return\r\n        count = find_partial_match_by_timestamp(self._partial_matches, last_timestamp - self._sliding_window)\r\n        self._partial_matches = self._partial_matches[count:]\r\n\r\n        \"\"\"\r\n        \"waiting for timeout\" contains matches that may be invalidated by a future negative event\r\n        if the timestamp has passed, they can't be invalidated anymore,\r\n        therefore we remove them from waiting for timeout\r\n        and we put them in the field \"matches to handle at eof\" of the root,\r\n        for it to put it in the matches at the end of the program\r\n        \"\"\"\r\n\r\n        if (type(self) == PostProcessingNode or type(self) == FirstChanceNode) \\\r\n                and self.is_last:\r\n            self._waiting_for_time_out = sorted(self._waiting_for_time_out, key=lambda x: x.first_timestamp)\r\n            count = find_partial_match_by_timestamp(self._waiting_for_time_out, last_timestamp - self._sliding_window)\r\n            node = self\r\n            while node._parent is not None:\r\n                node = node._parent\r\n\r\n            node.matches_to_handle_at_EOF.extend(self._waiting_for_time_out[:count]) # pourquoi ne pas les mettre directement dans root.partial_matches ?\r\n            self._waiting_for_time_out = self._waiting_for_time_out[count:]\r\n\r\n        \"\"\"\r\n        the end of the function is here to handle a special case: a pattern that starts by a negative event, and we got\r\n        a negative event that has invalidated the first part of a match but the second part of the match arrives later,\r\n        with a timestamp not \"influenced\" anymore by the negative event\r\n        example: notA, B, C : A has invalidated B, but C arrives later,\r\n        and the time window doesn't contain A and C at the same time. Therefore B, C is a match.\r\n        If a positive event (C) arrives with a timestamp that exceeds the frame of the negative event (A),\r\n        we want to remove the negative event and try to handle previous pm that were blocked by A (in our case: B)\r\n        Algorithm : we get all the FirstChanceNodes with flag is_first in the subtree of the current node\r\n        for each node, we remove the expired negative events, and we send back to the tree\r\n        all the pms contained in the field \"check_expired_timestamp\" that have been blocked\r\n        by a negative event that has expired.\r\n        \"\"\"\r\n\r\n        if self._parent is not None:\r\n            list_of_nodes = self._parent.get_first_FCNodes()\r\n        else:\r\n            list_of_nodes = self.get_first_FCNodes()\r\n\r\n        for node in list_of_nodes:\r\n            # node._right_subtree.clean_expired_partial_matches(last_timestamp)\r\n            if node._right_subtree._sliding_window == timedelta.max:\r\n                return\r\n            count = find_partial_match_by_timestamp(node._right_subtree._partial_matches,\r\n                                                    last_timestamp - node._right_subtree._sliding_window)\r\n            node._right_subtree._partial_matches = node._right_subtree._partial_matches[count:]\r\n\r\n            \"\"\"\r\n            partial_matches = []\r\n            for x, y in node.check_expired_timestamp.items():\r\n                if x <= last_timestamp:\r\n                    partial_matches.append(y)\r\n            \"\"\"\r\n\r\n            partial_matches = [pm for timestamp, pm in node.check_expired_timestamp if timestamp < last_timestamp]\r\n            # for timestamp, pm in node.check_expired_timestamp:\r\n            #     if timestamp < last_timestamp:\r\n            #         partial_matches.append(pm)\r\n\r\n            for pm in partial_matches:\r\n\r\n                \"\"\"\r\n                \"unblocking\" previous pms that were blocked by an expired neg event may lead to accept as a match\r\n                a pam that is in the time window of the negative event.\r\n                In our previous example, if a C1 arrived earlier and was blocked by A (like it should be),\r\n                removing the A now will cause C1 to go up the tree. Therefore we hold a threshold in a node,\r\n                which is the timestamp that a pm has t exceed to be a match\r\n                (when B, C1 go all the way up, we want to stop them because they are still in the time window of the previous A)\r\n                By default, the threshold is old by the root. If the root is a FirstChance Node with flag is_last on,\r\n                it may cause errors, and therefore we go down the tree from the root until we find a node that meets the criteria\r\n                \"\"\"\r\n\r\n                node_to_hold_threshold = self\r\n                while node_to_hold_threshold._parent is not None:\r\n                    node_to_hold_threshold = node_to_hold_threshold._parent\r\n\r\n                # need to check also that root.left_subtree is not leaf ?\r\n                while type(node_to_hold_threshold) == FirstChanceNode and node_to_hold_threshold.is_last:\r\n                    node_to_hold_threshold = node_to_hold_threshold._left_subtree\r\n\r\n                node_to_hold_threshold.threshold = last_timestamp\r\n\r\n                # we want to remove the pm from the check_expired_timestamp list\r\n                node.check_expired_timestamp = [x for x in node.check_expired_timestamp if x[1] != pm]\r\n\r\n                node._left_subtree._unhandled_partial_matches.put(pm)\r\n                node.handle_new_partial_match(node._left_subtree)\r\n\r\n                # now we turn the threshold off because we finished to handle this case\r\n                node_to_hold_threshold.threshold = 0\r\n\r\n    def add_partial_match(self, pm: PartialMatch):\r\n        \"\"\"\r\n        Registers a new partial match at this node.\r\n        As of now, the insertion is always by the timestamp, and the partial matches are stored in a list sorted by\r\n        timestamp. Therefore, the insertion operation is performed in O(log n).\r\n        \"\"\"\r\n        index = find_partial_match_by_timestamp(self._partial_matches, pm.first_timestamp)\r\n        self._partial_matches.insert(index, pm)\r\n        if self._parent is not None:\r\n            self._unhandled_partial_matches.put(pm)\r\n\r\n    def get_partial_matches(self):\r\n        \"\"\"\r\n        Returns the currently stored partial matches.\r\n        \"\"\"\r\n        return self._partial_matches\r\n\r\n    def get_first_FCNodes(self):\r\n        \"\"\"\r\n        Returns all FirstChance nodes with flag is_first on in the subtree of self - to be implemented by subclasses.\r\n        \"\"\"\r\n        raise NotImplementedError()\r\n\r\n    def get_leaves(self):\r\n        \"\"\"\r\n        Returns all leaves in this tree - to be implemented by subclasses.\r\n        \"\"\"\r\n        raise NotImplementedError()\r\n\r\n    def apply_formula(self, formula: Formula):\r\n        \"\"\"\r\n        Applies a given formula on all nodes in this tree - to be implemented by subclasses.\r\n        \"\"\"\r\n        raise NotImplementedError()\r\n\r\n    def get_event_definitions(self):\r\n        \"\"\"\r\n        Returns the specifications of all events collected by this tree - to be implemented by subclasses.\r\n        \"\"\"\r\n        raise NotImplementedError()\r\n\r\n    def get_deepest_leave(self):\r\n\r\n        raise NotImplementedError()\r\n\r\nclass LeafNode(Node):\r\n    \"\"\"\r\n    A leaf node is responsible for a single event type of the pattern.\r\n    \"\"\"\r\n\r\n    def __init__(self, sliding_window: timedelta, leaf_index: int, leaf_qitem: QItem, parent: Node):\r\n        super().__init__(sliding_window, parent)\r\n        self.__leaf_index = leaf_index\r\n        self.__event_name = leaf_qitem.name\r\n        self.__event_type = leaf_qitem.event_type\r\n\r\n        # We added an index for every QItem according to its place in the pattern in order to facilitate checking\r\n        # if a PartialMatch is in the right order chronologically (for SEQ)\r\n        self.qitem_index = leaf_qitem.get_event_index()\r\n\r\n    def get_leaves(self):\r\n        return [self]\r\n\r\n    def get_first_FCNodes(self):\r\n        return []\r\n\r\n    def get_deepest_leave(self):\r\n        return self\r\n\r\n    def set_qitem_index(self, index: int):\r\n        self.qitem_index = index\r\n\r\n    def apply_formula(self, formula: Formula):\r\n        condition = formula.get_formula_of(self.__event_name)\r\n        if condition is not None:\r\n            self._condition = condition\r\n\r\n    def get_event_definitions(self):\r\n        return [(self.__leaf_index, QItem(self.__event_type, self.__event_name, self.qitem_index))]\r\n\r\n    def get_event_type(self):\r\n        \"\"\"\r\n        Returns the type of events processed by this leaf.\r\n        \"\"\"\r\n        return self.__event_type\r\n\r\n    def handle_event(self, event: Event):\r\n        \"\"\"\r\n        Inserts the given event to this leaf.\r\n        \"\"\"\r\n        self.clean_expired_partial_matches(event.timestamp)\r\n\r\n        # get event's qitem and make a binding to evaluate formula for the new event.\r\n        binding = {self.__event_name: event.payload}\r\n\r\n        if not self._condition.eval(binding):\r\n            return\r\n\r\n        self.add_partial_match(PartialMatch([event]))\r\n        if self._parent is not None:\r\n            self._parent.handle_new_partial_match(self)\r\n\r\n    def get_event_name(self):\r\n        \"\"\"\r\n        Returns the name of the event processed by this leaf.\r\n        \"\"\"\r\n        return self.__event_name\r\n\r\n\r\nclass InternalNode(Node):\r\n    \"\"\"\r\n    An internal node connects two subtrees, i.e., two subpatterns of the evaluated pattern.\r\n    \"\"\"\r\n\r\n    def __init__(self, sliding_window: timedelta, parent: Node = None, event_defs: List[Tuple[int, QItem]] = None,\r\n                 left: Node = None, right: Node = None):\r\n        super().__init__(sliding_window, parent)\r\n        self._event_defs = event_defs\r\n        self._left_subtree = left\r\n        self._right_subtree = right\r\n        \"\"\"\r\n        Special field to be used in only one node (root or first node which is not a FC node) if the pattern contains\r\n        a negative operator, in mode \"first chance negation\".\r\n        In some cases, contains the threshold timestamp that a pm has to exceed in order to be a match - see clean_expired\r\n        Otherwise is 0\r\n        \"\"\"\r\n        self.threshold = 0\r\n\r\n    def get_leaves(self):\r\n        result = []\r\n        if self._left_subtree is not None:\r\n            result += self._left_subtree.get_leaves()\r\n        if self._right_subtree is not None:\r\n            result += self._right_subtree.get_leaves()\r\n        return result\r\n\r\n    def get_first_FCNodes(self):\r\n        result = []\r\n        if type(self._left_subtree) != LeafNode:\r\n            result += self._left_subtree.get_first_FCNodes()\r\n        if type(self._right_subtree) != LeafNode:\r\n            result += self._right_subtree.get_first_FCNodes()\r\n        return result\r\n\r\n    def get_deepest_leave(self):\r\n        if self._left_subtree is not None:\r\n            return self._left_subtree.get_deepest_leave()\r\n\r\n    def apply_formula(self, formula: Formula):\r\n        names = {item[1].name for item in self._event_defs}\r\n        condition = formula.get_formula_of(names)\r\n        self._condition = condition if condition else TrueFormula()\r\n        self._left_subtree.apply_formula(self._condition)\r\n        self._right_subtree.apply_formula(self._condition)\r\n\r\n    def get_event_definitions(self):\r\n        return self._event_defs\r\n\r\n    def _set_event_definitions(self,\r\n                               left_event_defs: List[Tuple[int, QItem]], right_event_defs: List[Tuple[int, QItem]]):\r\n        \"\"\"\r\n        A helper function for collecting the event definitions from subtrees. To be overridden by subclasses.\r\n        \"\"\"\r\n        self._event_defs = left_event_defs + right_event_defs\r\n\r\n    def set_subtrees(self, left: Node, right: Node):\r\n        \"\"\"\r\n        Sets the subtrees of this node.\r\n        \"\"\"\r\n        self._left_subtree = left\r\n        self._right_subtree = right\r\n        self._set_event_definitions(self._left_subtree.get_event_definitions(),\r\n                                    self._right_subtree.get_event_definitions())\r\n\r\n    def handle_new_partial_match(self, partial_match_source: Node):\r\n        \"\"\"\r\n        Internal node's update for a new partial match in one of the subtrees.\r\n        \"\"\"\r\n        if partial_match_source == self._left_subtree:\r\n            other_subtree = self._right_subtree\r\n        elif partial_match_source == self._right_subtree:\r\n            other_subtree = self._left_subtree\r\n        else:\r\n            raise Exception()  # should never happen\r\n\r\n        new_partial_match = partial_match_source.get_last_unhandled_partial_match()\r\n        first_event_defs = partial_match_source.get_event_definitions()\r\n        other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n        partial_matches_to_compare = other_subtree.get_partial_matches()\r\n        second_event_defs = other_subtree.get_event_definitions()\r\n\r\n        self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        # given a partial match from one subtree, for each partial match\r\n        # in the other subtree we check for new partial matches in this node.\r\n        for partialMatch in partial_matches_to_compare:\r\n            self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs)\r\n\r\n    def _try_create_new_match(self,\r\n                              first_partial_match: PartialMatch, second_partial_match: PartialMatch,\r\n                              first_event_defs: List[Tuple[int, QItem]], second_event_defs: List[Tuple[int, QItem]]):\r\n        \"\"\"\r\n        Verifies all the conditions for creating a new partial match and creates it if all constraints are satisfied.\r\n        \"\"\"\r\n        if self._sliding_window != timedelta.max and \\\r\n                abs(first_partial_match.last_timestamp - second_partial_match.first_timestamp) > self._sliding_window:\r\n            return\r\n        events_for_new_match = self._merge_events_for_new_match(first_event_defs, second_event_defs,\r\n                                                                first_partial_match.events, second_partial_match.events)\r\n\r\n        if not self._validate_new_match(events_for_new_match):\r\n            return\r\n\r\n        # If the threshold is not 0, we accept the pm as a match only if its last timestamp exceeds the threshold\r\n        if self.threshold != 0 and first_partial_match.last_timestamp < self.threshold:\r\n            return\r\n\r\n        self.add_partial_match(PartialMatch(events_for_new_match))\r\n        if self._parent is not None:\r\n            self._parent.handle_new_partial_match(self)\r\n\r\n    def _merge_events_for_new_match(self,\r\n                                    first_event_defs: List[Tuple[int, QItem]],\r\n                                    second_event_defs: List[Tuple[int, QItem]],\r\n                                    first_event_list: List[Event],\r\n                                    second_event_list: List[Event]):\r\n        \"\"\"\r\n        Creates a list of events to be included in a new partial match.\r\n        \"\"\"\r\n        if self._event_defs[0][0] == first_event_defs[0][0]:\r\n            return first_event_list + second_event_list\r\n        if self._event_defs[0][0] == second_event_defs[0][0]:\r\n            return second_event_list + first_event_list\r\n        raise Exception()\r\n\r\n    def _validate_new_match(self, events_for_new_match: List[Event]):\r\n        \"\"\"\r\n        Validates the condition stored in this node on the given set of events.\r\n        \"\"\"\r\n        binding = {\r\n            self._event_defs[i][1].name: events_for_new_match[i].payload for i in range(len(self._event_defs))\r\n        }\r\n        return self._condition.eval(binding)\r\n\r\n    \"\"\"\r\n    def sort_event_def_according_to(self, pattern: Pattern):\r\n        if(type(self) != InternalNegationNode):\r\n            return\r\n        pattern_list = pattern.origin_structure.get_args()\r\n        qitem_list = list(list(zip(*self._event_defs))[1])\r\n\r\n        qitem_list_name = [x.name for x in qitem_list]\r\n\r\n        for name in qitem_list_name:\r\n            if name == self._right_subtree.__event_name:\r\n                index_to_delete = qitem_list_name.index(name)\r\n                tuple_to_insert = self._event_defs.pop(index_to_delete)\r\n                break\r\n\r\n        for p in pattern_list:\r\n            if p.name == name:\r\n                new_index = pattern_list.index(p)\r\n\r\n        list_name = [x.name for x in list_for_sorting]\r\n\r\n\r\n        sorted_qitems = sorted(qitem_list, key=lambda x: x.get_event_index())\r\n        \"\"\"\r\n\r\n\r\nclass AndNode(InternalNode):\r\n    \"\"\"\r\n    An internal node representing an \"AND\" operator.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\nclass SeqNode(InternalNode):\r\n    \"\"\"\r\n    An internal node representing a \"SEQ\" (sequence) operator.\r\n    In addition to checking the time window and condition like the basic node does, SeqNode also verifies the order\r\n    of arrival of the events in the partial matches it constructs.\r\n    \"\"\"\r\n\r\n    def _set_event_definitions(self,\r\n                               left_event_defs: List[Tuple[int, QItem]], right_event_defs: List[Tuple[int, QItem]]):\r\n        self._event_defs = merge(left_event_defs, right_event_defs, key=lambda x: x[0])\r\n\r\n    def _merge_events_for_new_match(self,\r\n                                    first_event_defs: List[Tuple[int, QItem]],\r\n                                    second_event_defs: List[Tuple[int, QItem]],\r\n                                    first_event_list: List[Event],\r\n                                    second_event_list: List[Event]):\r\n        return merge_according_to(first_event_defs, second_event_defs,\r\n                                  first_event_list, second_event_list, key=lambda x: x[0])\r\n\r\n    def _validate_new_match(self, events_for_new_match: List[Event]):\r\n        if not is_sorted(events_for_new_match, key=lambda x: x.timestamp):\r\n            return False\r\n        return super()._validate_new_match(events_for_new_match)\r\n\r\n\r\nclass InternalNegationNode(InternalNode):\r\n    \"\"\"\r\n    Virtual class that represents a NOT operator. Has two subclasses, one for each mode\r\n    \"\"\"\r\n    def __init__(self, sliding_window: timedelta, is_first: bool, is_last: bool, top_operator, parent: Node = None,\r\n                 event_defs: List[Tuple[int, QItem]] = None,\r\n                 left: Node = None, right: Node = None):\r\n        super().__init__(sliding_window, parent, event_defs, left, right)\r\n        # Those are flags in order to differenciate the NegationNode if they are in the middle of a pattern, at the beginning or at the end\r\n        self.is_first = is_first\r\n        self.is_last = is_last\r\n        self.top_operator = top_operator\r\n\r\n        \"\"\"\r\n        Contains PMs that match the whole pattern, but may be invalidated by a negative event later \r\n        We wait for them to exceed the time window and therefore can't be invalidated anymore\r\n        \"\"\"\r\n        self._waiting_for_time_out = []\r\n\r\n        \"\"\"\r\n        Contains PMs that match the whole pattern and were in waiting_for_timeout, and now can't be invalidated anymore\r\n        When we finish all the stream of events we handle them and put them in the output\r\n        \"\"\"\r\n        self.matches_to_handle_at_EOF = []\r\n\r\n    def _set_event_definitions(self,\r\n                               left_event_defs: List[Tuple[int, QItem]], right_event_defs: List[Tuple[int, QItem]]):\r\n        self._event_defs = merge(left_event_defs, right_event_defs, key=get_index)  # test eva  verifier\r\n\r\n    def _merge_events_for_new_match(self,\r\n                                    first_event_defs: List[Tuple[int, QItem]],\r\n                                    second_event_defs: List[Tuple[int, QItem]],\r\n                                    first_event_list: List[Event],\r\n                                    second_event_list: List[Event]):\r\n        return merge_according_to(first_event_defs, second_event_defs,\r\n                                  first_event_list, second_event_list, key=lambda x: x[0])\r\n        # ici aussi faire get_index? En fait on dirait qu'on l'utilise pas finalement... A enlever?\r\n\r\n    def get_event_definitions(self):  # to support multiple neg\r\n        return self._left_subtree.get_event_definitions()  #  verifier\r\n\r\n    def _try_create_new_match(self,\r\n                              first_partial_match: PartialMatch, second_partial_match: PartialMatch,\r\n                              first_event_defs: List[Tuple[int, QItem]], second_event_defs: List[Tuple[int, QItem]]):\r\n\r\n        if self._sliding_window != timedelta.max and \\\r\n                abs(first_partial_match.last_timestamp - second_partial_match.first_timestamp) > self._sliding_window:\r\n            return\r\n\r\n        events_for_new_match = merge_according_to(first_event_defs, second_event_defs,\r\n                                                  first_partial_match.events, second_partial_match.events,\r\n                                                  key=get_index)\r\n\r\n        if self.top_operator == SeqOperator:\r\n            if not is_sorted(events_for_new_match, key=lambda x: x.timestamp):  # 17.06 a il faut verifier que si on est dans SEQ...\r\n                return False\r\n        elif self.top_operator == AndOperator:\r\n            \"\"\"\r\n                To be implemented later when class AndNode will be implemented\r\n            \"\"\"\r\n            raise NotImplementedError()\r\n        elif self.top_operator == OrOperator:\r\n            \"\"\"\r\n                To be implemented later when class OrNode will be implemented\r\n            \"\"\"\r\n            raise NotImplementedError()\r\n\r\n        return self._validate_new_match(events_for_new_match)\r\n\r\n    def _validate_new_match(self, events_for_new_match: List[Event]):\r\n        \"\"\"\r\n        Validates the condition stored in this node on the given set of events.\r\n        \"\"\"\r\n        binding = {\r\n            self._event_defs[i][1].name: events_for_new_match[i].payload for i in range(len(self._event_defs))\r\n        }\r\n        return self._condition.eval(binding)\r\n\r\n\r\nclass FirstChanceNode(InternalNegationNode):\r\n    \"\"\"\r\n        An internal node representing a Negation operator in case of FirstChance mode\r\n\r\n    \"\"\"\r\n    def __init__(self, sliding_window: timedelta, is_first: bool, is_last: bool, top_operator, parent: Node = None,\r\n                 event_defs: List[Tuple[int, QItem]] = None,\r\n                 left: Node = None, right: Node = None):\r\n        super().__init__(sliding_window, is_first, is_last, top_operator, parent, event_defs, left, right)\r\n\r\n        \"\"\"\r\n        contains PMs invalidated by a negative event,\r\n        but may be part of a bigger pm that exceeds the time window of the neg event later\r\n        \"\"\"\r\n\r\n        self.check_expired_timestamp = []\r\n\r\n    def handle_new_partial_match(self, partial_match_source: Node):\r\n\r\n        if partial_match_source == self._left_subtree:\r\n            # If we received events from the left_subtree => positive events\r\n            # we add them to the partial matches of this node and we continue on\r\n            new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # A1 et C1\r\n            other_subtree = self._right_subtree\r\n\r\n            if self.is_last:\r\n                self._waiting_for_time_out.append(new_partial_match)\r\n                return\r\n\r\n            first_event_defs = partial_match_source.get_event_definitions()\r\n            other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n            partial_matches_to_compare = other_subtree.get_partial_matches()  # B\r\n            second_event_defs = other_subtree.get_event_definitions()\r\n            self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n            invalidate = False\r\n            partialMatch = None\r\n            for partialMatch in partial_matches_to_compare:\r\n                # for every negative event, we want to check if he invalidates new_partial_match\r\n                if self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                    invalidate = True\r\n                    break\r\n\r\n            # if the flag is off is empty, there is no negative event that invalidated the current pm and therefore we go up\r\n            if invalidate is False:\r\n                self.add_partial_match(new_partial_match)\r\n                if self._parent is not None:\r\n                    self._parent.handle_new_partial_match(self)\r\n\r\n            if invalidate:\r\n                # if the new partial match is invalidated we want to check later if the negative event has expired\r\n                if partialMatch.first_timestamp != partialMatch.last_timestamp:\r\n                    print(\"partial match is not leaf event\")\r\n                # check_expired_timestamp.add(partialMatch.first_timestamp + self._sliding_window)\r\n                self.check_expired_timestamp.append((partialMatch.last_timestamp + self._sliding_window,\r\n                                                     new_partial_match))\r\n                # self.check_expired_timestamp[partialMatch.last_timestamp + self._sliding_window] = new_partial_match\r\n                # print(\"test:\", partialMatch.last_timestamp + self._sliding_window)\r\n\r\n            # else we do nothing ? or we need to remove the current pm from the list of pms all the way to the bottom ??\r\n            return\r\n\r\n        elif partial_match_source == self._right_subtree:\r\n            # the current pm is a negative event, we check if it invalidates previous pms\r\n            if self.is_first:\r\n                return\r\n            elif self.is_last:\r\n                self.handle_PM_with_negation_at_the_end(partial_match_source)\r\n                return\r\n            else:\r\n                new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # A1 et C1\r\n\r\n                other_subtree = self._left_subtree\r\n\r\n                first_event_defs = partial_match_source.get_event_definitions()\r\n                other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n                partial_matches_to_compare = other_subtree.get_partial_matches()  # B\r\n                second_event_defs = other_subtree.get_event_definitions()\r\n                self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n                partial_match_to_remove = []\r\n                for partialMatch in partial_matches_to_compare:  # for every negative event, we want to check if he invalidates new_partial_match\r\n                    if self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                        partial_match_to_remove.append(partialMatch)\r\n\r\n                # if the negative event invalidated some pms we want to remove all of them in each negative node in the way up\r\n\r\n                \"\"\"\r\n                for partialMatch in partial_match_to_remove:\r\n                    node = self\r\n                    while node is not None and type(node) == FirstChanceNode:\r\n                        node._remove_partial_matches(partialMatch)\r\n                        node = node._parent\r\n\r\n                \"\"\"\r\n                node = self\r\n                while node is not None and type(node) == FirstChanceNode:\r\n                    node._remove_partial_matches(partial_match_to_remove)\r\n                    node = node._parent\r\n\r\n    def _remove_partial_matches(self, matches_to_remove: List[PartialMatch]):\r\n        matches_to_keep = [match for match in self._partial_matches if match not in matches_to_remove]\r\n        # for match in self._partial_matches:\r\n        #     if match not in matches_to_remove:\r\n        #         matches_to_keep.append(match)\r\n\r\n        self._partial_matches = matches_to_keep\r\n        \"\"\"\r\n        i = 0\r\n        m = set(match_to_remove)\r\n        while i < len(self._partial_matches):\r\n            n = set(self._partial_matches[i].events)\r\n            if n.issubset(set(m)):\r\n                self._partial_matches.pop(i)\r\n            i += 1\r\n        self._partial_matches = [x for x in self._partial_matches.event if not set(x).issubset(m)]\r\n        \"\"\"\r\n\r\n    # This is a customized handle_new_partial_match function especially for PartialMatch that can possibly be invalidated by a later negative event\r\n    def handle_PM_with_negation_at_the_end(self, partial_match_source: Node):\r\n\r\n        other_subtree = self.get_first_last_negative_node()\r\n\r\n        new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # C\r\n        first_event_defs = partial_match_source.get_event_definitions()\r\n        other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        partial_matches_to_compare = self.get_waiting_for_time_out()\r\n        second_event_defs = other_subtree.get_event_definitions()\r\n        self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        matches_to_keep = []\r\n        for partialMatch in partial_matches_to_compare:  # pour chaque pm qu'on a \"bloqu\" on verifie si le nouveau event not va invalider\r\n            if not self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                matches_to_keep.append(partialMatch)\r\n\r\n        other_subtree._waiting_for_time_out = matches_to_keep\r\n\r\n    def get_waiting_for_time_out(self):\r\n        if (type(self._left_subtree) == PostProcessingNode or type(self._left_subtree) == FirstChanceNode) \\\r\n                and self._left_subtree.is_last:\r\n            return self._left_subtree.get_waiting_for_time_out()\r\n        else:\r\n            return self._waiting_for_time_out\r\n\r\n    # This function descends in the tree and returns us the first Node that is not a NegationNode at the end of the Pattern\r\n    def get_first_last_negative_node(self):\r\n        if (type(self._left_subtree) == PostProcessingNode or type(self._left_subtree) == FirstChanceNode) \\\r\n                and self._left_subtree.is_last:\r\n            return self._left_subtree.get_first_last_negative_node()\r\n        else:\r\n            return self\r\n\r\n    def get_first_FCNodes(self):\r\n        if self.is_first:\r\n            return [self]\r\n        else:\r\n            return []\r\n\r\n\r\nclass PostProcessingNode(InternalNegationNode):\r\n    \"\"\"\r\n    An internal node connects two subtrees, i.e., two subpatterns of the evaluated pattern.\r\n    \"\"\"\r\n\r\n    def __init__(self, sliding_window: timedelta, is_first: bool, is_last: bool, top_operator, parent: Node = None,\r\n                 event_defs: List[Tuple[int, QItem]] = None,\r\n                 left: Node = None, right: Node = None):\r\n        super().__init__(sliding_window, is_first, is_last, top_operator, parent, event_defs, left, right)\r\n\r\n    \"\"\"\r\n        if type(self._left_subtree) != LeafNode:\r\n            return self._left_subtree._validate_new_match(events_for_new_match)\r\n        else:\r\n            return super()._validate_new_match(events_for_new_match)\r\n\r\n    def _remove_partial_match(self, match_to_remove: List[Event]):\r\n        i = 0\r\n        m = set(match_to_remove)\r\n        while i < len(self._left_subtree._partial_matches):\r\n            n = set(self._left_subtree._partial_matches[i].events)\r\n            if n.issubset(set(m)):\r\n                self._left_subtree._partial_matches.pop(i)\r\n            i += 1\r\n        #self._left_subtree._partial_matches = [x for x in self._left_subtree._partial_matches.event if not set(x).issubset(m)]\r\n    \"\"\"\r\n\r\n    def get_waiting_for_time_out(self):\r\n        if type(self._left_subtree) == PostProcessingNode and self._left_subtree.is_last:\r\n            return self._left_subtree.get_waiting_for_time_out()\r\n        else:\r\n            return self._waiting_for_time_out\r\n\r\n    # This function descends in the tree and returns us the first Node that is not a NegationNode at the end of the Pattern\r\n    def get_first_last_negative_node(self):\r\n        if type(self._left_subtree) == PostProcessingNode and self._left_subtree.is_last:\r\n            return self._left_subtree.get_first_last_negative_node()\r\n        else:\r\n            return self\r\n\r\n    # This is a customized handle_new_partial_match function especially for PartialMatch that can possibly be invalidated by a later negative event\r\n    def handle_PM_with_negation_at_the_end(self, partial_match_source: Node):\r\n\r\n        other_subtree = self.get_first_last_negative_node()\r\n\r\n        new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # C\r\n        first_event_defs = partial_match_source.get_event_definitions()\r\n        other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        partial_matches_to_compare = self.get_waiting_for_time_out()\r\n        second_event_defs = other_subtree.get_event_definitions()\r\n        self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        matches_to_keep = []\r\n        for partialMatch in partial_matches_to_compare:  # pour chaque pm qu'on a \"bloqu\" on verifie si le nouveau event not va invalider\r\n            if not self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                matches_to_keep.append(partialMatch)\r\n\r\n        other_subtree._waiting_for_time_out = matches_to_keep\r\n\r\n    def handle_new_partial_match(self, partial_match_source: Node):\r\n\r\n        if partial_match_source == self._left_subtree:\r\n            other_subtree = self._right_subtree\r\n            if self.is_last:\r\n                new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # A1 et C1\r\n                self._waiting_for_time_out.append(new_partial_match)\r\n                return\r\n\r\n        elif partial_match_source == self._right_subtree:\r\n            if self.is_last:\r\n                self.handle_PM_with_negation_at_the_end(partial_match_source)\r\n            return\r\n            # si on vient de rajouter un QItem qui est NOT, on ne veut rien faire avec,\r\n            # on ne veut ni le faire monter en tant que partial match ni comparer avec les autres.\r\n        else:\r\n            raise Exception()  # should never happen\r\n\r\n        new_partial_match = partial_match_source.get_last_unhandled_partial_match()  # A1 et C1\r\n        first_event_defs = partial_match_source.get_event_definitions()\r\n        other_subtree.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        partial_matches_to_compare = other_subtree.get_partial_matches()  # B\r\n        second_event_defs = other_subtree.get_event_definitions()\r\n        self.clean_expired_partial_matches(new_partial_match.last_timestamp)\r\n\r\n        for partialMatch in partial_matches_to_compare:  # for every negative event, we want to check if he invalidates new_partial_match\r\n            if self._try_create_new_match(new_partial_match, partialMatch, first_event_defs, second_event_defs):\r\n                return\r\n\r\n        self.add_partial_match(new_partial_match)\r\n        if self._parent is not None:\r\n            self._parent.handle_new_partial_match(self)\r\n\r\n\r\nclass Tree:\r\n    \"\"\"\r\n    Represents an evaluation tree. Implements the functionality of constructing an actual tree from a \"tree structure\"\r\n    object returned by a tree builder. Other than that, merely acts as a proxy to the tree root node.\r\n    \"\"\"\r\n\r\n    def __init__(self, tree_structure: tuple, pattern: Pattern):\r\n        # Note that right now only \"flat\" sequence patterns and \"flat\" conjunction patterns are supported\r\n\r\n        # We create a tree with only the positive event and the conditions that apply to them\r\n        temp_root = Tree.__construct_tree(pattern.structure.get_top_operator() == SeqOperator,\r\n                                          tree_structure, pattern.structure.args, pattern.window)\r\n        temp_root.apply_formula(pattern.condition)\r\n\r\n        self.__root = temp_root\r\n\r\n        # According to the flag PostProcessing or FirstChanceProcessing, we add the negative events in a different way\r\n        PostProcessing = False\r\n        if PostProcessing:\r\n            self.__root = self.create_PostProcessing_Tree(temp_root, pattern)\r\n        else:\r\n            self.__root = self.create_FirstChanceNegation_Tree(pattern)\r\n\r\n    def create_FirstChanceNegation_Tree(self, pattern: Pattern):\r\n\r\n        top_operator = pattern.origin_structure.get_top_operator()\r\n\r\n        negative_event_list = pattern.negative_event.get_args()\r\n        origin_event_list = pattern.origin_structure.get_args()\r\n\r\n        # init node to use it out of the scope of the for\r\n        node = self.__root\r\n        for p in negative_event_list:\r\n            flag = 1\r\n            p_conditions = pattern.condition.get_events_in_a_condition_with(p.get_event_name())\r\n            set_of_depending_events = set()\r\n            if p_conditions is not None:\r\n                p_conditions.get_all_terms(set_of_depending_events)\r\n            if pattern.origin_structure.get_top_operator() == SeqOperator:\r\n                find_positive_events_before(p, set_of_depending_events, pattern.origin_structure.get_args())\r\n            if p.get_event_name() in set_of_depending_events:\r\n                set_of_depending_events.remove(p.get_event_name())\r\n            # list_of_depending_events = list(set(list_of_depending_events))\r\n            node = self.__root.get_deepest_leave()  # A CHANGER\r\n            while flag:\r\n                names = {item[1].name for item in node.get_event_definitions()}\r\n                result = all(elem in names for elem in set_of_depending_events)\r\n                counter = 0\r\n                if result:\r\n                    while type(node._parent) == FirstChanceNode:\r\n                        node = node._parent\r\n                    if p == origin_event_list[counter]:\r\n                        temporal_root = FirstChanceNode(pattern.window, is_first=True, is_last=False, top_operator=top_operator)\r\n                        counter += 1\r\n                    elif len(negative_event_list) - negative_event_list.index(p) \\\r\n                            == len(origin_event_list) - origin_event_list.index(p):\r\n                        temporal_root = FirstChanceNode(pattern.window, is_first=False, is_last=True, top_operator=top_operator)\r\n                    else:\r\n                        temporal_root = FirstChanceNode(pattern.window, is_first=False, is_last=False, top_operator=top_operator)\r\n\r\n                    # temporal_root = InternalNegationNode(pattern.window, is_first=False, is_last=False)\r\n                    temp_neg_event = LeafNode(pattern.window, 1, p, temporal_root)\r\n                    temp_neg_event.apply_formula(pattern.condition)\r\n                    temporal_root.set_subtrees(node, temp_neg_event)\r\n                    temp_neg_event.set_parent(temporal_root)\r\n                    temporal_root.set_parent(node._parent)\r\n                    node.set_parent(temporal_root)\r\n                    if temporal_root._parent != None:\r\n                        temporal_root._parent.set_subtrees(temporal_root, temporal_root._parent._right_subtree)\r\n\r\n                    names = {item[1].name for item in temporal_root._event_defs}\r\n                    condition = pattern.condition.get_formula_of(names)\r\n                    temporal_root._condition = condition if condition else TrueFormula()\r\n\r\n                    flag = 0\r\n                else:\r\n                    node = node._parent\r\n\r\n        while node._parent != None:\r\n            node = node._parent\r\n        self.__root = node\r\n        # self.reorder_event_def(pattern)\r\n\r\n        return self.__root\r\n\r\n    def create_PostProcessing_Tree(self, temp_root: Node, pattern: Pattern):\r\n\r\n        top_operator = pattern.origin_structure.get_top_operator()\r\n        negative_event_list = pattern.negative_event.get_args()\r\n        origin_event_list = pattern.origin_structure.get_args()\r\n        counter = 0\r\n        for p in negative_event_list:\r\n            if p == origin_event_list[counter]:\r\n                temporal_root = PostProcessingNode(pattern.window, is_first=True, is_last=False,\r\n                                                   top_operator=top_operator)\r\n                counter += 1\r\n            elif len(negative_event_list) - negative_event_list.index(p) \\\r\n                    == len(origin_event_list) - origin_event_list.index(p):\r\n                temporal_root = PostProcessingNode(pattern.window, is_first=False, is_last=True,\r\n                                                   top_operator=top_operator)\r\n            else:\r\n                temporal_root = PostProcessingNode(pattern.window, is_first=False, is_last=False,\r\n                                                   top_operator=top_operator)\r\n\r\n            temp_neg_event = LeafNode(pattern.window, 1, p, temporal_root)\r\n            temporal_root.set_subtrees(temp_root, temp_neg_event)\r\n            temp_neg_event.set_parent(temporal_root)\r\n            temp_root.set_parent(temporal_root)\r\n            temp_root = temp_root._parent\r\n            # Peut tre  enlever?\r\n            names = {item[1].name for item in temp_root._event_defs}\r\n            condition = pattern.condition.get_formula_of(names)\r\n            temp_root._condition = condition if condition else TrueFormula()\r\n\r\n        self.__root = temp_root\r\n        # self.reorder_event_def(pattern)\r\n        return self.__root\r\n        # self.__root.apply_formula(pattern.condition)\r\n\r\n    def get_root(self):\r\n        return self.__root\r\n\r\n    def reorder_event_def(self, pattern: Pattern):\r\n        current_node = self.__root\r\n        while type(current_node) != LeafNode:\r\n            # if (type(current_node) == InternalNegationNode):\r\n            current_node._event_defs.sort(key=get_index)\r\n            current_node = current_node._left_subtree\r\n\r\n    def handle_EOF(self, matches: Stream):\r\n        for match in self.__root.matches_to_handle_at_EOF:\r\n            matches.add_item(PatternMatch(match.events))\r\n        node = self.__root.get_first_last_negative_node()\r\n        for match in node._waiting_for_time_out:\r\n            matches.add_item(PatternMatch(match.events))\r\n\r\n    def get_leaves(self):\r\n        return self.__root.get_leaves()\r\n\r\n    def get_matches(self):\r\n        while self.__root.has_partial_matches():\r\n            yield self.__root.consume_first_partial_match().events\r\n\r\n    @staticmethod\r\n    def __construct_tree(is_sequence: bool, tree_structure: tuple or int, args: List[QItem],\r\n                         sliding_window: timedelta, parent: Node = None):\r\n        if type(tree_structure) == int:\r\n            return LeafNode(sliding_window, tree_structure, args[tree_structure], parent)\r\n        current = SeqNode(sliding_window, parent) if is_sequence else AndNode(sliding_window, parent)\r\n        left_structure, right_structure = tree_structure\r\n        left = Tree.__construct_tree(is_sequence, left_structure, args, sliding_window, current)\r\n        right = Tree.__construct_tree(is_sequence, right_structure, args, sliding_window, current)\r\n        current.set_subtrees(left, right)\r\n        return current\r\n\r\n\r\nclass TreeBasedEvaluationMechanism(EvaluationMechanism):\r\n    \"\"\"\r\n    An implementation of the tree-based evaluation mechanism.\r\n    \"\"\"\r\n\r\n    def __init__(self, pattern: Pattern, tree_structure: tuple):\r\n        self.__tree = Tree(tree_structure, pattern)\r\n\r\n    def eval(self, events: Stream, matches: Stream):\r\n        event_types_listeners = {}\r\n        # register leaf listeners for event types.\r\n        for leaf in self.__tree.get_leaves():\r\n            event_type = leaf.get_event_type()\r\n            if event_type in event_types_listeners.keys():\r\n                event_types_listeners[event_type].append(leaf)\r\n            else:\r\n                event_types_listeners[event_type] = [leaf]\r\n\r\n        # Send events to listening leaves.\r\n        for event in events:\r\n            if event.event_type in event_types_listeners.keys():\r\n                for leaf in event_types_listeners[event.event_type]:\r\n                    leaf.handle_event(event)\r\n                    for match in self.__tree.get_matches():\r\n                        matches.add_item(PatternMatch(match))\r\n\r\n        # if type(self.__tree.get_root()) == InternalNegationNode and self.__tree.get_root().is_last:\r\n        # if type(self.__tree.get_root()) == PostProcessingNode and self.__tree.get_root().is_last:\r\n        #     self.__tree.handle_EOF(matches)\r\n        # if type(self.__tree.get_root()) == FirstChanceNode and self.__tree.get_root().is_last:\r\n        #     self.__tree.handle_EOF(matches)\r\n\r\n        if (type(self.__tree.get_root()) == PostProcessingNode or type(self.__tree.get_root()) == FirstChanceNode) \\\r\n                and self.__tree.get_root().is_last:\r\n            self.__tree.handle_EOF(matches)\r\n\r\n        matches.close()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- evaluation/TreeBasedEvaluationMechanism.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ evaluation/TreeBasedEvaluationMechanism.py	(date 1593952807093)
@@ -10,10 +10,10 @@
 from misc.Utils import merge, merge_according_to, is_sorted, find_partial_match_by_timestamp, get_index, \
     find_positive_events_before
 from base.PatternMatch import PatternMatch
-from evaluation.EvaluationMechanism import EvaluationMechanism
+from evaluation.EvaluationMechanism import EvaluationMechanism, NegationMode
+#from evaluation.EvaluationMechanismFactory import NegationMode
 from queue import Queue
 
-# check_expired_timestamp = set()
 
 class Node(ABC):
     """
@@ -25,7 +25,7 @@
         self._sliding_window = sliding_window
         self._partial_matches = []
         self._condition = TrueFormula()
-        # matches that were not yet pushed to the parent for further processing
+        # matches that were not yet pushed to the parent for further processing => waiting for a potential not yhat could invalidate our match
         self._unhandled_partial_matches = Queue()
 
     def consume_first_partial_match(self):
@@ -707,22 +707,6 @@
                  left: Node = None, right: Node = None):
         super().__init__(sliding_window, is_first, is_last, top_operator, parent, event_defs, left, right)
 
-    """
-        if type(self._left_subtree) != LeafNode:
-            return self._left_subtree._validate_new_match(events_for_new_match)
-        else:
-            return super()._validate_new_match(events_for_new_match)
-
-    def _remove_partial_match(self, match_to_remove: List[Event]):
-        i = 0
-        m = set(match_to_remove)
-        while i < len(self._left_subtree._partial_matches):
-            n = set(self._left_subtree._partial_matches[i].events)
-            if n.issubset(set(m)):
-                self._left_subtree._partial_matches.pop(i)
-            i += 1
-        #self._left_subtree._partial_matches = [x for x in self._left_subtree._partial_matches.event if not set(x).issubset(m)]
-    """
 
     def get_waiting_for_time_out(self):
         if type(self._left_subtree) == PostProcessingNode and self._left_subtree.is_last:
@@ -798,7 +782,7 @@
     object returned by a tree builder. Other than that, merely acts as a proxy to the tree root node.
     """
 
-    def __init__(self, tree_structure: tuple, pattern: Pattern):
+    def __init__(self, tree_structure: tuple, pattern: Pattern, eval_mechanims_params):
         # Note that right now only "flat" sequence patterns and "flat" conjunction patterns are supported
 
         # We create a tree with only the positive event and the conditions that apply to them
@@ -809,11 +793,13 @@
         self.__root = temp_root
 
         # According to the flag PostProcessing or FirstChanceProcessing, we add the negative events in a different way
-        PostProcessing = False
-        if PostProcessing:
+        negation_mode = eval_mechanims_params.negation_mode
+        if negation_mode == NegationMode.POST_PROCESSING:
             self.__root = self.create_PostProcessing_Tree(temp_root, pattern)
-        else:
+        elif negation_mode == NegationMode.FIRST_CHANCE:
             self.__root = self.create_FirstChanceNegation_Tree(pattern)
+        else:
+            raise Exception()  # should never happen
 
     def create_FirstChanceNegation_Tree(self, pattern: Pattern):
 
@@ -873,8 +859,6 @@
         while node._parent != None:
             node = node._parent
         self.__root = node
-        # self.reorder_event_def(pattern)
-
         return self.__root
 
     def create_PostProcessing_Tree(self, temp_root: Node, pattern: Pattern):
@@ -907,20 +891,11 @@
             temp_root._condition = condition if condition else TrueFormula()
 
         self.__root = temp_root
-        # self.reorder_event_def(pattern)
         return self.__root
-        # self.__root.apply_formula(pattern.condition)
 
     def get_root(self):
         return self.__root
 
-    def reorder_event_def(self, pattern: Pattern):
-        current_node = self.__root
-        while type(current_node) != LeafNode:
-            # if (type(current_node) == InternalNegationNode):
-            current_node._event_defs.sort(key=get_index)
-            current_node = current_node._left_subtree
-
     def handle_EOF(self, matches: Stream):
         for match in self.__root.matches_to_handle_at_EOF:
             matches.add_item(PatternMatch(match.events))
@@ -953,8 +928,8 @@
     An implementation of the tree-based evaluation mechanism.
     """
 
-    def __init__(self, pattern: Pattern, tree_structure: tuple):
-        self.__tree = Tree(tree_structure, pattern)
+    def __init__(self, pattern: Pattern, tree_structure: tuple, eval_mechanism_params):
+        self.__tree = Tree(tree_structure, pattern, eval_mechanism_params)
 
     def eval(self, events: Stream, matches: Stream):
         event_types_listeners = {}
@@ -974,11 +949,6 @@
                     for match in self.__tree.get_matches():
                         matches.add_item(PatternMatch(match))
 
-        # if type(self.__tree.get_root()) == InternalNegationNode and self.__tree.get_root().is_last:
-        # if type(self.__tree.get_root()) == PostProcessingNode and self.__tree.get_root().is_last:
-        #     self.__tree.handle_EOF(matches)
-        # if type(self.__tree.get_root()) == FirstChanceNode and self.__tree.get_root().is_last:
-        #     self.__tree.handle_EOF(matches)
 
         if (type(self.__tree.get_root()) == PostProcessingNode or type(self.__tree.get_root()) == FirstChanceNode) \
                 and self.__tree.get_root().is_last:
Index: evaluation/LeftDeepTreeBuilders.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nThis file contains the implementations of algorithms constructing a left-deep tree-based evaluation mechanism.\r\n\"\"\"\r\nfrom enum import Enum\r\nimport random\r\nfrom typing import List\r\n\r\nfrom evaluation.IterativeImprovement import IterativeImprovementType, IterativeImprovementAlgorithmBuilder\r\nfrom evaluation.TreeBasedEvaluationMechanism import TreeBasedEvaluationMechanism\r\nfrom evaluation.EvaluationMechanismBuilder import EvaluationMechanismBuilder\r\nfrom base.Pattern import Pattern\r\nfrom misc.Statistics import calculate_left_deep_tree_cost_function, MissingStatisticsException\r\nfrom misc.StatisticsTypes import StatisticsTypes\r\nfrom misc.Utils import get_order_by_occurrences\r\n\r\n\r\nclass LeftDeepTreeBuilder(EvaluationMechanismBuilder):\r\n    \"\"\"\r\n    An abstract class for left-deep tree builders.\r\n    \"\"\"\r\n    def build_single_pattern_eval_mechanism(self, pattern: Pattern):\r\n        order = self._create_evaluation_order(pattern)\r\n        tree_structure = self.__build_tree_from_order(order)\r\n        return TreeBasedEvaluationMechanism(pattern, tree_structure)\r\n\r\n    def build_multi_pattern_eval_mechanism(self, patterns: List[Pattern]):\r\n        raise Exception(\"Unsupported\")\r\n\r\n    @staticmethod\r\n    def __build_tree_from_order(order: List[int]):\r\n        \"\"\"\r\n        Builds a left-deep tree structure from a given order.\r\n        \"\"\"\r\n        ret = order[0]\r\n        for i in range(1, len(order)):\r\n            ret = (ret, order[i])\r\n        return ret\r\n\r\n    def _create_evaluation_order(self, pattern: Pattern):\r\n        \"\"\"\r\n        To be implemented by subclasses.\r\n        \"\"\"\r\n        raise NotImplementedError()\r\n\r\n\r\nclass TrivialLeftDeepTreeBuilder(LeftDeepTreeBuilder):\r\n    \"\"\"\r\n    Creates a left-deep tree following the pattern-specified order.\r\n    \"\"\"\r\n    def _create_evaluation_order(self, pattern: Pattern):\r\n        args_num = len(pattern.structure.args)\r\n        return list(range(args_num))\r\n\r\n\r\nclass AscendingFrequencyTreeBuilder(LeftDeepTreeBuilder):\r\n    \"\"\"\r\n    Creates a left-deep tree following the order of ascending arrival rates of the event types.\r\n    \"\"\"\r\n    def _create_evaluation_order(self, pattern: Pattern):\r\n        if pattern.statistics_type == StatisticsTypes.FREQUENCY_DICT:\r\n            frequency_dict = pattern.statistics\r\n            order = get_order_by_occurrences(pattern.structure.args, frequency_dict)\r\n        elif pattern.statistics_type == StatisticsTypes.ARRIVAL_RATES:\r\n            arrival_rates = pattern.statistics\r\n            # create an index-arrival rate binding and sort according to arrival rate.\r\n            sorted_order = sorted([(i, arrival_rates[i]) for i in range(len(arrival_rates))], key=lambda x: x[1])\r\n            order = [x for x, y in sorted_order]  # create order from sorted binding.\r\n        else:\r\n            raise MissingStatisticsException()\r\n        return order\r\n\r\n\r\nclass GreedyLeftDeepTreeBuilder(LeftDeepTreeBuilder):\r\n    \"\"\"\r\n    Creates a left-deep tree using a greedy strategy that selects at each step the event type that minimizes the cost\r\n    function.\r\n    \"\"\"\r\n    def _create_evaluation_order(self, pattern: Pattern):\r\n        if pattern.statistics_type == StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES:\r\n            (selectivityMatrix, arrivalRates) = pattern.statistics\r\n        else:\r\n            raise MissingStatisticsException()\r\n        return self.calculate_greedy_order(selectivityMatrix, arrivalRates)\r\n\r\n    @staticmethod\r\n    def calculate_greedy_order(selectivity_matrix: List[List[float]], arrival_rates: List[int]):\r\n        \"\"\"\r\n        At any step we will only consider the intermediate partial matches size,\r\n        even without considering the sliding window, because the result is independent of it.\r\n        For each unselected item, we will calculate the speculated\r\n        effect to the partial matches, and choose the one with minimal increase.\r\n        We don't even need to calculate the cost function.\r\n        \"\"\"\r\n        size = len(selectivity_matrix)\r\n        if size == 1:\r\n            return [0]\r\n\r\n        new_order = []\r\n        left_to_add = set(range(len(selectivity_matrix)))\r\n        while len(left_to_add) > 0:\r\n            # create first nominee to add.\r\n            to_add = to_add_start = left_to_add.pop()\r\n            min_change_factor = selectivity_matrix[to_add][to_add]\r\n            for j in new_order:\r\n                min_change_factor *= selectivity_matrix[to_add][j]\r\n\r\n            # find minimum change factor and its according index.\r\n            for i in left_to_add:\r\n                change_factor = selectivity_matrix[i][i] * arrival_rates[i]\r\n                for j in new_order:\r\n                    change_factor *= selectivity_matrix[i][j]\r\n                if change_factor < min_change_factor:\r\n                    min_change_factor = change_factor\r\n                    to_add = i\r\n            new_order.append(to_add)\r\n\r\n            # if it wasn't the first nominee, then we need to fix the starting speculation we did.\r\n            if to_add != to_add_start:\r\n                left_to_add.remove(to_add)\r\n                left_to_add.add(to_add_start)\r\n\r\n        return new_order\r\n\r\n\r\nclass IterativeImprovementInitType(Enum):\r\n    RANDOM = 0\r\n    GREEDY = 1\r\n\r\n\r\nclass IterativeImprovementLeftDeepTreeBuilder(LeftDeepTreeBuilder):\r\n    \"\"\"\r\n    Creates a left-deep tree using the iterative improvement procedure.\r\n    \"\"\"\r\n    def __init__(self, step_limit: int,\r\n                 ii_type: IterativeImprovementType = IterativeImprovementType.SWAP_BASED,\r\n                 init_type: IterativeImprovementInitType = IterativeImprovementInitType.RANDOM):\r\n        self.__iterative_improvement = IterativeImprovementAlgorithmBuilder.create_ii_algorithm(ii_type)\r\n        self.__initType = init_type\r\n        self.__step_limit = step_limit\r\n\r\n    def _create_evaluation_order(self, pattern: Pattern):\r\n        if pattern.statistics_type == StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES:\r\n            (selectivityMatrix, arrivalRates) = pattern.statistics\r\n        else:\r\n            raise MissingStatisticsException()\r\n        order = None\r\n        if self.__initType == IterativeImprovementInitType.RANDOM:\r\n            order = self.__get_random_order(len(arrivalRates))\r\n        elif self.__initType == IterativeImprovementInitType.GREEDY:\r\n            order = GreedyLeftDeepTreeBuilder.calculate_greedy_order(selectivityMatrix, arrivalRates)\r\n        return self.__iterative_improvement.execute(self.__step_limit, order, selectivityMatrix, arrivalRates,\r\n                                                    pattern.window.total_seconds())\r\n\r\n    @staticmethod\r\n    def __get_random_order(n: int):\r\n        \"\"\"\r\n        Used for creating an initial order in RANDOM mode.\r\n        \"\"\"\r\n        order = []\r\n        left = list(range(n))\r\n        while len(left) > 0:\r\n            index = random.randint(0, len(left) - 1)\r\n            order.append(left[index])\r\n            del left[index]\r\n        return order\r\n\r\n\r\nclass DynamicProgrammingLeftDeepTreeBuilder(LeftDeepTreeBuilder):\r\n    \"\"\"\r\n    Creates a left-deep tree using a dynamic programming algorithm.\r\n    \"\"\"\r\n    def _create_evaluation_order(self, pattern: Pattern):\r\n        if pattern.statistics_type == StatisticsTypes.SELECTIVITY_MATRIX_AND_ARRIVAL_RATES:\r\n            (selectivityMatrix, arrivalRates) = pattern.statistics\r\n        else:\r\n            raise MissingStatisticsException()\r\n        return DynamicProgrammingLeftDeepTreeBuilder.find_order(selectivityMatrix, arrivalRates,\r\n                                                                pattern.window.total_seconds())\r\n\r\n    @staticmethod\r\n    def find_order(selectivity_matrix: List[List[float]], arrival_rates: List[int], window: int):\r\n        args_num = len(selectivity_matrix)\r\n        if args_num == 1:  # boring extreme case\r\n            return [0]\r\n\r\n        items = frozenset(range(args_num))\r\n        # Save subsets' optimal orders, the cost and the left to add items.\r\n        sub_orders = {frozenset({i}): ([i],\r\n                                       calculate_left_deep_tree_cost_function([i], selectivity_matrix, arrival_rates,\r\n                                                                              window),\r\n                                       items.difference({i}))\r\n                      for i in items}\r\n\r\n        for i in range(2, args_num + 1):\r\n            # for each subset of size i, we will find the best order for each subset\r\n            next_orders = {}\r\n            for subset in sub_orders.keys():\r\n                order, _, left_to_add = sub_orders[subset]\r\n                for item in left_to_add:\r\n                    # calculate for optional order for set of size i\r\n                    new_subset = frozenset(subset.union({item}))\r\n                    new_cost = calculate_left_deep_tree_cost_function(order, selectivity_matrix, arrival_rates, window)\r\n                    # check if it is not the first order for that set\r\n                    if new_subset in next_orders.keys():\r\n                        _, t_cost, t_left = next_orders[new_subset]\r\n                        if new_cost < t_cost:  # check if it is the current best order for that set\r\n                            new_order = order + [item]\r\n                            next_orders[new_subset] = new_order, new_cost, t_left\r\n                    else:  # if it is the first order for that set\r\n                        new_order = order + [item]\r\n                        next_orders[new_subset] = new_order, new_cost, left_to_add.difference({item})\r\n            # update subsets for next iteration\r\n            sub_orders = next_orders\r\n        return list(sub_orders.values())[0][\r\n            0]  # return the order (at index 0 in the tuple) of item 0, the only item in subsets of size n.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- evaluation/LeftDeepTreeBuilders.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ evaluation/LeftDeepTreeBuilders.py	(date 1593952004606)
@@ -18,10 +18,10 @@
     """
     An abstract class for left-deep tree builders.
     """
-    def build_single_pattern_eval_mechanism(self, pattern: Pattern):
+    def build_single_pattern_eval_mechanism(self, pattern: Pattern, eval_mechanism_params):
         order = self._create_evaluation_order(pattern)
         tree_structure = self.__build_tree_from_order(order)
-        return TreeBasedEvaluationMechanism(pattern, tree_structure)
+        return TreeBasedEvaluationMechanism(pattern, tree_structure, eval_mechanism_params)
 
     def build_multi_pattern_eval_mechanism(self, patterns: List[Pattern]):
         raise Exception("Unsupported")
Index: CEP.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nThis file contains the primary engine. It processes streams of events and detects pattern matches\r\nby invoking the rest of the system components.\r\n\"\"\"\r\nfrom misc.IOUtils import Stream\r\nfrom base.Pattern import Pattern\r\nfrom evaluation.EvaluationMechanismFactory import EvaluationMechanismParameters, \\\r\n    EvaluationMechanismTypes, EvaluationMechanismFactory\r\nfrom typing import List\r\nfrom datetime import datetime\r\n\r\n\r\nclass PerformanceSpecifications:\r\n    \"\"\"\r\n    A sketch of QoS specifications, we assume it will be an object constructed separately, and the\r\n    CEP engine will refer to it if it is passed.\r\n    Not implemented yet.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\nclass CEP:\r\n    \"\"\"\r\n    A CEP object contains a workload (list of patterns to be evaluated) and an evaluation mechanism.\r\n    The evaluation mechanism is created according to the parameters specified in the constructor.\r\n    \"\"\"\r\n    def __init__(self, patterns: List[Pattern],\r\n                 eval_mechanism_type: EvaluationMechanismTypes = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE,\r\n                 NegationMode : bool = 0,\r\n                 eval_mechanism_params: EvaluationMechanismParameters = None,\r\n                 performance_specs: PerformanceSpecifications = None):\r\n        \"\"\"\r\n        Constructor of the class.\r\n        \"\"\"\r\n        if patterns is None:\r\n            raise Exception(\"No patterns are provided\")\r\n        if len(patterns) > 1:\r\n            raise NotImplementedError(\"Multi-pattern support is not yet available\")\r\n\r\n        \"\"\"\r\n                For PostProcessing Mode, NegationMode = 0\r\n                For FirstChance Mode, NegationMode = 1\r\n                When there isn't any NegationOperator, it doesn't really matter, but we set in PostProcessing Mode by default\r\n                \"\"\"\r\n\r\n        self.NegationMode = NegationMode\r\n\r\n        self.__eval_mechanism = EvaluationMechanismFactory.build_single_pattern_eval_mechanism(eval_mechanism_type,\r\n                                                                                               eval_mechanism_params,\r\n                                                                                               patterns[0])\r\n\r\n        self.__pattern_matches = None\r\n        self.__performance_specs = performance_specs\r\n\r\n\r\n\r\n    def run(self, event_stream: Stream):\r\n        \"\"\"\r\n        Applies the evaluation mechanism to detect the predefined patterns in a given stream of events.\r\n        Returns the total time elapsed during evaluation.\r\n        \"\"\"\r\n        self.__pattern_matches = Stream()\r\n        start = datetime.now()\r\n        self.__eval_mechanism.eval(event_stream, self.__pattern_matches)\r\n        return (datetime.now() - start).total_seconds()\r\n\r\n    def get_pattern_match(self):\r\n        \"\"\"\r\n        Returns one match from the output stream.\r\n        \"\"\"\r\n        if self.__pattern_matches is None:\r\n            return None\r\n        try:\r\n            return self.__pattern_matches.get_item()\r\n        except StopIteration:  # the stream might be closed.\r\n            return None\r\n\r\n    def get_pattern_match_stream(self):\r\n        \"\"\"\r\n        Returns the output stream containing the detected matches.\r\n        \"\"\"\r\n        return self.__pattern_matches\r\n\r\n    # For future support of dynamic workload modification\r\n    def add_pattern(self, pattern: Pattern, priority: int = 0):\r\n        raise NotImplementedError()\r\n\r\n    # For future support of dynamic workload modification\r\n    def remove_pattern(self, pattern: Pattern, priority: int = 0):\r\n        raise NotImplementedError()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- CEP.py	(revision 7c8b36e798f6d83412556a2b0f64b402ae93c487)
+++ CEP.py	(date 1593952116373)
@@ -5,7 +5,7 @@
 from misc.IOUtils import Stream
 from base.Pattern import Pattern
 from evaluation.EvaluationMechanismFactory import EvaluationMechanismParameters, \
-    EvaluationMechanismTypes, EvaluationMechanismFactory
+    EvaluationMechanismTypes, EvaluationMechanismFactory, NegationMode
 from typing import List
 from datetime import datetime
 
@@ -26,8 +26,7 @@
     """
     def __init__(self, patterns: List[Pattern],
                  eval_mechanism_type: EvaluationMechanismTypes = EvaluationMechanismTypes.TRIVIAL_LEFT_DEEP_TREE,
-                 NegationMode : bool = 0,
-                 eval_mechanism_params: EvaluationMechanismParameters = None,
+                 eval_mechanism_params: EvaluationMechanismParameters = EvaluationMechanismParameters(),
                  performance_specs: PerformanceSpecifications = None):
         """
         Constructor of the class.
@@ -37,13 +36,6 @@
         if len(patterns) > 1:
             raise NotImplementedError("Multi-pattern support is not yet available")
 
-        """
-                For PostProcessing Mode, NegationMode = 0
-                For FirstChance Mode, NegationMode = 1
-                When there isn't any NegationOperator, it doesn't really matter, but we set in PostProcessing Mode by default
-                """
-
-        self.NegationMode = NegationMode
 
         self.__eval_mechanism = EvaluationMechanismFactory.build_single_pattern_eval_mechanism(eval_mechanism_type,
                                                                                                eval_mechanism_params,
